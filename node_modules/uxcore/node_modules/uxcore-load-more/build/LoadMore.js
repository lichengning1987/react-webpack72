/**
 * LoadMore Component for uxcore
 * @author peijie.dpj
 *
 * Copyright 2015-2016, Uxcore Team, Alinw.
 * All rights reserved.
 */

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('react');
var classnames = require('classnames');
var lang = require('./i18n');

var scrollTimer = void 0;

var LoadMore = function (_React$Component) {
  _inherits(LoadMore, _React$Component);

  function LoadMore(props) {
    _classCallCheck(this, LoadMore);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.lang = lang[props.locale.toLocaleLowerCase()];
    return _this;
  }

  LoadMore.prototype.componentDidMount = function componentDidMount() {
    var me = this,
        props = me.props;

    var hasView = props.trigger.some(function (item) {
      return item == 'view';
    });

    if (hasView && (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object') {
      if (window.addEventListener) {
        window.addEventListener('scroll', me.onScroll.bind(me));
      } else if (window.attachEvent) {
        window.attachEvent('onscroll', me.onScroll.bind(me));
      }

      // 第一屏判断
      if (me.isElementInView(me.refs.viewMore)) {
        props.onLoadMore();
      }
    }
  };

  /**
   * 滚动事件
   */


  LoadMore.prototype.onScroll = function onScroll() {
    var me = this,
        props = me.props;

    if (scrollTimer) {
      clearTimeout(scrollTimer);
    }

    scrollTimer = setTimeout(me.onScrollStop.bind(me), props.viewLoadDelay);
  };

  /**
   * 滚动停止一段时间之后才判断
   */


  LoadMore.prototype.onScrollStop = function onScrollStop() {
    var me = this,
        props = me.props;

    if (me.isElementInView(me.refs.viewMore)) {
      props.onLoadMore();
    }
  };

  LoadMore.prototype.onClick = function onClick() {
    var me = this,
        props = me.props;

    var hasClick = props.trigger.some(function (item) {
      return item == 'click';
    });

    if (hasClick) {
      props.onLoadMore();
    }
  };

  LoadMore.prototype.isElementInView = function isElementInView(element) {
    if (!element || (typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object') {
      return false;
    }

    var threshold = 0,
        innerHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight,
        viewTop = window.scrollY || window.pageYOffset || document.documentElement.scrollTop,
        viewBottom = viewTop + innerHeight,
        elementTop = !!element && !!element.getBoundingClientRect && element.getBoundingClientRect().top + viewTop,
        elementBottom = elementTop + element.offsetHeight,
        offset = threshold / 100 * innerHeight;

    return viewTop - offset <= elementBottom && elementTop <= viewBottom + offset;
  };

  LoadMore.prototype._renderLoadStatus = function _renderLoadStatus() {
    var me = this,
        props = me.props,
        lang = me.lang,
        res = void 0;

    switch (props.status) {
      case 'loaded':
        res = React.createElement(
          'a',
          { href: 'javascript:void(0)', className: props.prefixCls + '-status', ref: 'viewMore', onClick: me.onClick.bind(me) },
          'loadText' in props ? props.loadText : lang.viewMore
        );
        break;

      case 'loading':
        res = React.createElement(
          'a',
          { href: 'javascript:void(0)', className: props.prefixCls + '-status' },
          React.createElement('i', { className: props.prefixCls + '-icon-loading' }),
          'loadingText' in props ? props.loadingText : lang.loading
        );
        break;

      case 'noMore':
        res = React.createElement(
          'a',
          { href: 'javascript:void(0)', className: props.prefixCls + '-status ' + props.prefixCls + '-noMore' },
          'noMoreText' in props ? props.noMoreText : lang.noMore
        );
        break;
    }

    return res;
  };

  LoadMore.prototype.render = function render() {
    var _classnames;

    var me = this,
        props = me.props;

    return React.createElement(
      'div',
      { className: classnames(props.prefixCls, (_classnames = {}, _classnames[props.className] = !!props.className, _classnames)) },
      me._renderLoadStatus()
    );
  };

  return LoadMore;
}(React.Component);

LoadMore.defaultProps = {
  prefixCls: 'kuma-load-more',
  status: 'loaded',
  className: '',
  trigger: ['view', 'click'],
  onLoadMore: function onLoadMore() {},
  locale: 'zh-cn',
  viewLoadDelay: 150
};

// http://facebook.github.io/react/docs/reusable-components.html
LoadMore.propTypes = {
  prefixCls: React.PropTypes.string,
  status: React.PropTypes.oneOf(['loaded', 'loading', 'noMore']),
  className: React.PropTypes.string,
  trigger: React.PropTypes.array,
  onLoadMore: React.PropTypes.func,
  locale: React.PropTypes.oneOf(['zh-cn', 'en-us']),
  viewLoadDelay: React.PropTypes.number
};

LoadMore.displayName = "LoadMore";

module.exports = LoadMore;