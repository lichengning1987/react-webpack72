'use strict';

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var React = require('react');
var ReactDOM = require('react-dom');

var _require = require('uploadcore');

var UploadCore = _require.UploadCore;
var Events = _require.Events;
var Status = _require.Status;

var util = require("./util");
var FileList = require("./FileList");
var Picker = require("./Picker");
var Dropzoom = require('./Dropzoom');
var i18n = require("./locale");
var RESETOPTIONS = ['name', 'url', 'params', 'action', 'data', 'headers', 'withCredentials', 'timeout', 'chunkEnable', 'chunkSize', 'chunkRetries', 'chunkProcessThreads', 'autoPending', 'auto', 'sizeLimit', 'fileSizeLimit'];

var Uploader = function (_React$Component) {
    _inherits(Uploader, _React$Component);

    function Uploader(props) {
        _classCallCheck(this, Uploader);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _this.core = util.getCoreInstance(props, true);
        _this.fileList = _this.getDefaultList();
        _this.state = {
            total: _this.core.getTotal(),
            fileList: _this.processDefaultList(_this.fileList)
        };
        return _this;
    }

    Uploader.prototype.componentWillMount = function componentWillMount() {
        var _this2 = this;

        var me = this;
        var _me$props = me.props;
        var onfileuploadsuccess = _me$props.onfileuploadsuccess;
        var onfilecancel = _me$props.onfilecancel;
        var onCancel = _me$props.onCancel;
        var preventDuplicate = _me$props.preventDuplicate;

        me.statchange = function (stat) {
            var total = stat.getTotal();
            if (total !== me.state.total) {
                me.setState({ total: total });
            }
        };
        me.fileuploadsuccess = function (file, response) {
            var newList = util.simpleDeepCopy(me.state.fileList);
            newList.push(me.processFile(file));
            me.handleChange(newList);
            file.cancel(true);
            me.core.getStat().remove(file);
            // onfileuploadsuccess && onfileuploadsuccess(file, response);
        };

        me.filecancel = function (file) {
            var newList = util.simpleDeepCopy(me.state.fileList);
            newList.push({
                type: 'delete',
                response: file.response.getJson()
            });
            me.handleChange(newList);
            onfilecancel && onfilecancel(file);
            onCancel && onCancel(me.processFile(file));
        };
        me.core.on(Events.QUEUE_STAT_CHANGE, me.statchange);
        me.core.on(Events.FILE_UPLOAD_SUCCESS, me.fileuploadsuccess);
        me.core.on(Events.FILE_CANCEL, me.filecancel);
        me.core.addConstraint(function () {
            if (me.props.queueCapcity === undefined || me.props.queueCapcity === null) {
                return false;
            } else {
                return me.state.fileList.filter(function (file) {
                    return file.type !== 'delete';
                }).length + me.core.getTotal() >= me.props.queueCapcity;
            }
        });
        me.core.addFilter(function (file) {
            if (preventDuplicate) {
                if (_this2.state.fileList.some(function (item) {
                    return item.type === 'upload' && item.name === file.name && item.size === file.size;
                })) {
                    return 'DuplicateError: ' + file.name + ' is duplicated';
                }
            }
        });
    };

    Uploader.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var me = this;
        var newState = {};
        var options = {};
        if (!util.simpleDeepEqual(nextProps.fileList, me.fileList)) {
            me.fileList = me.getDefaultList(nextProps);
            me.setState({
                fileList: me.processDefaultList(me.fileList)
            });
        }
        RESETOPTIONS.forEach(function (item) {
            if (nextProps.hasOwnProperty(item) && me.props[item] !== nextProps[item]) {
                options[item] = nextProps[item];
            }
        });
        me.core.setOptions && me.core.setOptions(options);
    };

    Uploader.prototype.componentWillUnmount = function componentWillUnmount() {
        this.stopListen();
    };

    Uploader.prototype.getCore = function getCore() {
        return this.core;
    };

    Uploader.prototype.stopListen = function stopListen() {
        this.core.off(Events.QUEUE_STAT_CHANGE, this.statchange);
        this.core.off(Events.FILE_UPLOAD_SUCCESS, this.fileuploadsuccess);
        this.core.off(Events.FILE_CANCEL, this.filecancel);
    };

    Uploader.prototype.reset = function reset() {
        this.core.getFiles().forEach(function (file) {
            file.cancel(true);
        });
    };

    /**
     * deepcopy props.filelist for comparision in `componentWillReceiveProps`
     */


    Uploader.prototype.getDefaultList = function getDefaultList(props) {
        var me = this;
        props = props || me.props;
        return util.simpleDeepCopy(props.fileList);
    };

    Uploader.prototype.addUniqueIdForList = function addUniqueIdForList(fileList) {
        var newList = util.simpleDeepCopy(fileList);
        newList = newList.map(function (file, index) {
            file.__uploaderId = 'uploader' + index;
            return file;
        });
        return newList;
    };

    Uploader.prototype.processFile = function processFile(file) {
        return {
            ext: file.ext,
            name: file.name,
            size: file.size,
            fileType: file.type,
            type: 'upload',
            response: file.response.getJson()
        };
    };

    Uploader.prototype.processDefaultList = function processDefaultList(fileList) {
        var me = this;
        return me.addUniqueIdForList(fileList).map(function (file) {
            return me.processDefaultListFile(file);
        });
    };

    /**
     * process file in this.props.fileList
     */


    Uploader.prototype.processDefaultListFile = function processDefaultListFile(file) {
        !file.type && (file.type = 'list');
        return file;
    };

    Uploader.prototype.handleRemoveFile = function handleRemoveFile(file) {
        var me = this;
        var newList = util.simpleDeepCopy(me.state.fileList);
        newList = newList.map(function (item) {
            if (item.__uploaderId === file.__uploaderId) {
                item.subType = item.type;
                item.type = 'delete';
            }
            return item;
        });
        me.handleChange(newList);
        me.props.onCancel && me.props.onCancel(file);
    };

    Uploader.prototype.handleChange = function handleChange(fileList) {
        var me = this;
        me.props.onChange(fileList);
    };

    Uploader.prototype.render = function render() {
        var me = this;
        var _props = this.props;
        var children = _props.children;
        var locale = _props.locale;

        if (!children || children.length < 1) {
            children = React.createElement(
                'button',
                { className: 'kuma-upload-button' },
                React.createElement('i', { className: 'kuma-icon kuma-icon-uploading' }),
                i18n[locale]['upload_files']
            );
        }
        return React.createElement(
            'div',
            { className: "kuma-uploader " + (this.props.className || '') },
            React.createElement(
                Picker,
                { core: this.core },
                children
            ),
            this.props.tips,
            this.state.total > 0 || this.state.fileList.length > 0 ? React.createElement(FileList, { locale: this.props.locale, core: this.core, isOnlyImg: this.props.isOnlyImg, mode: 'nw', fileList: me.state.fileList, removeFileFromList: me.handleRemoveFile.bind(me), interval: this.props.progressInterval }) : null
        );
    };

    return Uploader;
}(React.Component);

Uploader.Dropzoom = Dropzoom;

Uploader.Events = Events;
Uploader.Status = Status;
Uploader.setSWF = function (swf) {
    UploadCore.setSWF(swf);
};

Uploader.displayName = "Uploader";

Uploader.defaultProps = {
    locale: 'zh-cn',
    fileList: [],
    onChange: function onChange() {},
    onError: function onError() {}
};

Uploader.propTypes = {
    locale: React.PropTypes.string,
    fileList: React.PropTypes.array,
    onChange: React.PropTypes.func,
    onError: React.PropTypes.func
};

module.exports = Uploader;