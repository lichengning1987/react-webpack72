'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Table Component for uxcore
 * @author zhouquan.yezq
 *
 * Copyright 2014-2015, UXCore Team, Alinw.
 * All rights reserved.
 */

/* eslint "no-underscore-dangle": "off" */

var Header = require('./Header');
var Tbody = require('./Tbody');
var ActionBar = require('./ActionBar');
var CellField = require('./Cell/CellField');
var Pagination = require('uxcore-pagination');
var Const = require('uxcore-const');
var assign = require('object-assign');
var deepcopy = require('deepcopy');
var deepEqual = require('deep-equal');
var classnames = require('classnames');
var util = require('./util');
var NattyFetch = require('natty-fetch/dist/natty-fetch.pc');
var Promise = require('lie');
var React = require('react');
var Mask = require('./Mask');

var Table = function (_React$Component) {
  _inherits(Table, _React$Component);

  function Table(props) {
    _classCallCheck(this, Table);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.uid = 0;
    _this.fields = {};
    _this.state = {
      data: _this.addValuesInData(deepcopy(_this.props.jsxdata)), // checkbox 内部交互
      columns: _this.processColumn(), // column 内部交互
      showMask: props.showMask, // fetchData 时的内部状态改变
      pageSize: props.pageSize, // pagination 相关
      currentPage: props.currentPage, // pagination 相关
      activeColumn: null,
      scrollLeft: 0,
      scrollTop: 0,
      searchTxt: '',
      expandedKeys: []
    };
    _this.handleBodyScroll = _this.handleBodyScroll.bind(_this);
    _this.hasFixed = _this.hasFixColumn(props);
    return _this;
  }

  Table.prototype.componentWillMount = function componentWillMount() {
    if (this.props.fetchDataOnMount) {
      this.fetchData();
    }
  };

  Table.prototype.componentDidMount = function componentDidMount() {
    var me = this;
    if (!!me.state.data && !!me.state.data.datas) {
      console.warn("Table: 'content.data' rather than 'content.datas' is recommended, the support for 'content.datas' will be end from ver. 1.5.0");
    }
    if (me.props.subComp) {
      console.warn('Table: subComp is deprecated, use renderSubComp instead.');
    }
  };

  Table.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var me = this;
    var newData = {};
    if (nextProps.jsxdata && me.props.jsxdata && !me._isEqual(nextProps.jsxdata, me.props.jsxdata)) {
      // Data has changed, so uid which is used to mark the data should be reset.
      me.uid = 0;
      me.fetchData('dataChange', nextProps);
    }
    if (nextProps.pageSize !== me.props.pageSize) {
      newData.pageSize = nextProps.pageSize;
    }
    if (nextProps.currentPage !== me.props.currentPage) {
      newData.currentPage = nextProps.currentPage;
    }
    if (!!nextProps.jsxcolumns && !!me.props.jsxcolumns && !me._isEqual(nextProps.jsxcolumns, me.props.jsxcolumns)) {
      newData.columns = me.processColumn(nextProps);
      this.hasFixed = this.hasFixColumn(nextProps);
    }
    if (nextProps.showMask !== me.props.showMask) {
      newData.showMask = nextProps.showMask;
    }
    if (nextProps.fetchUrl !== me.props.fetchUrl || !me._isEqual(nextProps.fetchParams, me.props.fetchParams)) {
      me.fetchData('propsChange', nextProps);
    }
    me.setState(newData);
  };

  /**
   * cancel the CellField when it is unmounted.
   * @param field {element} the cell field to be canceled.
   */

  Table.prototype.detachCellField = function detachCellField(name) {
    delete this.fields[name];
  };

  /**
   * simple method to compare two datas,
   * only support the data which JSON can parse.
   */

  Table.prototype._isEqual = function _isEqual(a, b) {
    return deepEqual(a, b);
  };

  /**
   * get Query Object by combining data from searchBar, column order, pagination
   * and fetchParams.
   * @param from {string} used in props.beforeFetch
   */

  Table.prototype.getQueryObj = function getQueryObj(from, props) {
    var me = this;
    var queryObj = {};
    if (props.passedData) {
      var queryKeys = props.queryKeys;
      if (!queryKeys) {
        queryObj = props.passedData;
      } else {
        queryKeys.forEach(function (key) {
          if (props.passedData[key] !== undefined) {
            queryObj[key] = props.passedData[key];
          }
        });
      }
    }

    // pagination
    queryObj = assign({}, queryObj, {
      pageSize: me.state.pageSize,
      currentPage: me.state.currentPage
    });

    // column order
    var activeColumn = me.state.activeColumn;
    var orderType = me.state.orderType;
    if (activeColumn) {
      queryObj = assign({}, queryObj, {
        orderColumn: activeColumn.dataKey
      });
      if (orderType && orderType !== 'none') {
        queryObj.orderType = orderType;
      }
    }

    // search query
    var searchTxt = me.state.searchTxt;
    if (searchTxt) {
      queryObj = assign({}, queryObj, {
        searchTxt: searchTxt
      });
    }

    // fetchParams has the top priority
    if (props.fetchParams) {
      queryObj = assign({}, queryObj, props.fetchParams);
    }

    return props.beforeFetch(queryObj, from);
  };

  /**
   * fetch Data via Ajax
   * @param from {string} tell fetchData where it is invoked, the param will be
   * passed to props.beforeFetch in order to help the user.
   */

  Table.prototype.fetchData = function fetchData(from, nextProps) {
    var me = this;
    var props = nextProps || this.props;
    // reset uid cause table data has changed
    me.uid = 0;

    // fetchUrl has the top priority.
    if (props.fetchUrl) {
      if (me.request) {
        me.request.abort();
      }
      if (!me.state.showMask) {
        me.setState({
          showMask: true
        });
      }
      var isJsonp = props.isJsonp === undefined ? /\.jsonp/.test(props.fetchUrl) : props.isJsonp;
      me.request = NattyFetch.create({
        url: props.fetchUrl,
        data: me.getQueryObj(from, props),
        fit: props.fitResponse,
        jsonp: isJsonp,
        Promise: Promise
      });

      me.request().then(function (content) {
        var processedData = me.addValuesInData(props.processData(deepcopy(content)));
        var updateObj = {
          data: processedData,
          showMask: false
        };
        if (processedData.currentPage !== undefined) {
          updateObj.currentPage = processedData.currentPage;
        }
        me.data = deepcopy(processedData);
        me.setState(updateObj);
      })["catch"](function (err) {
        props.onFetchError(err);
      });
    } else if (props.passedData) {
      if (!props.queryKeys) {
        var data = me.addValuesInData(props.processData(deepcopy(props.passedData)));
        me.setState({
          data: data
        });
        me.data = deepcopy(data);
      } else {
        (function () {
          var data = {};
          props.queryKeys.forEach(function (key) {
            if (props.passedData[key] !== undefined) {
              data[key] = props.passedData[key];
            }
          });
          var processedData = me.addValuesInData(props.processData(deepcopy(data)));
          me.setState({
            data: processedData
          });
          me.data = deepcopy(processedData);
        })();
      }
    } else if (props.jsxdata) {
      if (['pagination', 'order', 'search'].indexOf(from) !== -1) {
        switch (from) {
          case 'pagination':
            if (props.onPagerChange) {
              props.onPagerChange(me.state.currentPage, me.state.pageSize);
            }
            break;
          case 'order':
            if (props.onOrder) {
              props.onOrder(me.state.activeColumn, me.state.orderType);
            }
            break;
          case 'search':
            if (props.onSearch) {
              props.onSearch(me.state.searchTxt);
            }
            break;
        }
      } else {
        var _data2 = this.addValuesInData(deepcopy(props.jsxdata));
        var currentPage = _data2 && _data2.currentPage || this.state.currentPage;
        me.setState({
          data: _data2,
          currentPage: currentPage
        });
        me.data = deepcopy(_data2);
      }
    } else {
      // default will create one row
      var _data3 = {
        data: [{
          jsxid: me.uid++,
          __mode__: Const.MODE.EDIT
        }],
        currentPage: 1,
        totalCount: 0
      };
      me.data = _data3;
      me.setState({
        data: _data3
      });
    }
  };

  Table.prototype.processColumn = function processColumn(props) {
    props = props || this.props;

    var me = this,
        columns = deepcopy(props.jsxcolumns),
        hasCheckboxColumn = false;

    columns.forEach(function (item, i) {
      // only one rowSelector can be rendered in Table.
      if (item.type === 'checkbox' || item.type === 'radioSelector' || item.type === 'checkboxSelector') {
        if (item.type === 'checkbox') {
          console.warn("rowSelector using 'type: checkbox' is deprecated, use 'type: checkboxSelector' instead.");
        }
        hasCheckboxColumn = true;
        me.checkboxColumn = item;
        me.checkboxColumnKey = item.dataKey;
        item.width = item.width || (/kuma-uxtable-border-line/.test(props.className) ? 40 : 32);
        item.align = item.align || 'left';
      }
    });

    // filter the column which has a dataKey 'jsxchecked' & 'jsxtreeIcon'

    columns = columns.filter(function (item) {
      return item.dataKey !== 'jsxchecked' && item.dataKey !== 'jsxtreeIcon';
    });

    if (!!props.rowSelection & !hasCheckboxColumn) {
      me.checkboxColumn = {
        dataKey: 'jsxchecked',
        width: 46,
        type: props.rowSelector,
        align: 'right'
      };
      me.checkboxColumnKey = 'jsxchecked';
      columns = [me.checkboxColumn].concat(columns);
    } else if (props.parentHasCheckbox) {
      // no rowSelection but has parentHasCheckbox, render placeholder
      columns = [{
        dataKey: 'jsxwhite',
        width: 46,
        type: 'empty'
      }].concat(columns);
    }
    if ((!!props.subComp || !!props.renderSubComp) && props.renderModel !== 'tree') {
      columns = [{
        dataKey: 'jsxtreeIcon',
        width: 34,
        type: 'treeIcon'
      }].concat(columns);
    } else if (props.passedData) {
      // no subComp but has passedData, means sub mode, parent should has tree icon,
      // render tree icon placeholder
      columns = [{
        dataKey: 'jsxwhite',
        width: 34,
        type: 'empty'
      }].concat(columns);
    }
    return columns;
  };

  Table.prototype.handleColumnPickerChange = function handleColumnPickerChange(checkedKeys) {
    if (checkedKeys.length === 0) {
      return;
    }
    var columns = deepcopy(this.state.columns);
    var notRenderColumns = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];

    for (var i = 0; i < columns.length; i++) {
      var item = columns[i];
      if ('group' in item) {
        for (var j = 0; j < item.columns.length; j++) {
          var ele = item.columns[j];
          if (checkedKeys.indexOf(ele.dataKey) !== -1) {
            ele.hidden = false;
          } else {
            ele.hidden = true;
          }
        }
      } else if (checkedKeys.indexOf(item.dataKey) !== -1 || notRenderColumns.indexOf(item.dataKey) !== -1) {
        item.hidden = false;
      } else {
        item.hidden = true;
      }
    }

    this.setState({
      columns: columns
    });
  };

  /**
   * change SelectedRows data via checkbox, this function will pass to the Cell
   * @param checked {boolean} the checkbox status
   * @param rowIndex {number} the row Index
   * @param fromMount {boolean} onSelect is called from cell Mount is not expected.
   */

  Table.prototype.changeSelected = function changeSelected(checked, rowIndex, fromMount) {
    var me = this;
    var content = deepcopy(this.state.data);
    var _data = content.datas || content.data;

    if (me.checkboxColumn.type === 'radioSelector') {
      for (var i = 0; i < _data.length; i++) {
        var item = _data[i];
        if (item.jsxid === rowIndex) {
          item[me.checkboxColumnKey] = checked;
        } else if (item[me.checkboxColumnKey]) {
          item[me.checkboxColumnKey] = false;
        }
      }
    } else {
      for (var _i = 0; _i < _data.length; _i++) {
        var _item = _data[_i];
        if (_item.jsxid === rowIndex) {
          _item[me.checkboxColumnKey] = checked;
          break;
        }
      }
    }

    me.setState({
      data: content
    }, function () {
      if (!fromMount) {
        var data = me.state.data.datas || me.state.data.data;
        var selectedRows = data.filter(function (item) {
          return item[me.checkboxColumnKey] === true;
        });
        if (me.props.rowSelection && me.props.rowSelection.onSelect) {
          me.props.rowSelection.onSelect(checked, data[rowIndex], selectedRows);
        }
      }
    });
  };

  /**
   * change the checkboxColumnKey of data, passed to the Row
   * @param checked {boolean} tree checkbox status
   * @param dataIndex {string} like `1-2-3` means the position of the Row in data
   */


  Table.prototype.changeTreeSelected = function changeTreeSelected(checked, dataIndex) {
    var me = this;
    var currentLevel = dataIndex.toString().split('-');
    var levelDepth = currentLevel.length;
    var data = deepcopy(me.state.data);
    var current = data.data;
    // record each tree node for reverse recursion.
    var treeMap = [];
    for (var i = 0; i < levelDepth - 1; i++) {
      treeMap[i] = current;
      current = current[currentLevel[i]].data;
    }
    // check/uncheck current row and all its children
    current = current[currentLevel[levelDepth - 1]];
    current[me.checkboxColumnKey] = checked;
    util.changeValueR(current, me.checkboxColumnKey, checked);

    // reverse recursion, check/uncheck parents by its children.
    for (var _i2 = treeMap.length - 1; _i2 >= 0; _i2--) {
      treeMap[_i2][currentLevel[_i2]][me.checkboxColumnKey] = treeMap[_i2][currentLevel[_i2]].data.every(function (item) {
        return item[me.checkboxColumnKey] === true;
      });
    }

    me.setState({
      data: data
    }, function () {
      var selectedRows = util.getAllSelectedRows(deepcopy(data), me.checkboxColumnKey);
      if (me.props.rowSelection && me.props.rowSelection.onSelect) {
        me.props.rowSelection.onSelect(checked, current, selectedRows);
      }
    });
  };

  Table.prototype.selectAll = function selectAll(checked) {
    var me = this;
    var content = deepcopy(me.state.data);
    var data = content.datas || content.data;
    var rowSelection = me.props.rowSelection;

    var selectedRows = [];
    for (var i = 0; i < data.length; i++) {
      var column = me.checkboxColumn;
      var key = me.checkboxColumnKey;
      var item = data[i];
      if ((!('isDisable' in column) || !column.isDisable(item)) && !column.disable) {
        item[key] = checked;
        selectedRows.push(item);
      }
    }

    if (!!rowSelection && !!rowSelection.onSelectAll) {
      rowSelection.onSelectAll.apply(null, [checked, checked ? selectedRows : []]);
    }
    me.setState({
      data: content
    });
  };

  Table.prototype.onPageChange = function onPageChange(current) {
    var me = this;
    me.setState({
      currentPage: current
    }, function () {
      me.fetchData('pagination');
    });
  };

  Table.prototype.handleShowSizeChange = function handleShowSizeChange(current, pageSize) {
    var me = this;
    me.setState({
      currentPage: current,
      pageSize: pageSize
    }, function () {
      me.fetchData('pagination');
    });
  };

  Table.prototype.getDomNode = function getDomNode() {
    return this.refs.root;
  };

  Table.prototype.renderPager = function renderPager() {
    var me = this;
    var _me$state = me.state;
    var data = _me$state.data;
    var currentPage = _me$state.currentPage;
    var pageSize = _me$state.pageSize;
    var _me$props = me.props;
    var showPagerTotal = _me$props.showPagerTotal;
    var showPager = _me$props.showPager;
    var locale = _me$props.locale;
    var pagerSizeOptions = _me$props.pagerSizeOptions;
    var isMiniPager = _me$props.isMiniPager;
    var showPagerSizeChanger = _me$props.showPagerSizeChanger;

    if (showPager && data && data.totalCount) {
      return React.createElement(
        'div',
        { className: 'kuma-uxtable-page' },
        React.createElement(Pagination, {
          className: classnames({
            mini: isMiniPager
          }),
          locale: locale,
          showSizeChanger: showPagerSizeChanger,
          showTotal: showPagerTotal,
          total: data.totalCount,
          onShowSizeChange: me.handleShowSizeChange.bind(me),
          onChange: me.onPageChange.bind(me),
          current: currentPage,
          pageSize: pageSize,
          sizeOptions: pagerSizeOptions
        })
      );
    }
    return null;
  };

  Table.prototype.handleBodyScroll = function handleBodyScroll(scrollLeft, scrollTop) {
    var me = this;
    var headerNode = me.hasFixed ? me.refs.headerScroll : me.refs.headerNo;
    var bodyNode = me.refs.bodyFixed;
    if (scrollLeft !== undefined) {
      headerNode.getDomNode().scrollLeft = scrollLeft;
    }
    if (scrollTop !== undefined && this.hasFixed) {
      bodyNode.getDomNode().scrollTop = scrollTop;
    }
  };

  Table.prototype.handleOrderColumnCB = function handleOrderColumnCB(type, column) {
    var me = this;
    me.setState({
      activeColumn: column,
      orderType: type
    }, function () {
      me.fetchData('order');
    });
  };

  Table.prototype.handleActionBarSearch = function handleActionBarSearch(value) {
    var me = this;
    this.setState({
      searchTxt: value
    }, function () {
      me.fetchData('search');
    });
  };

  Table.prototype.getData = function getData(validate) {
    var me = this;
    var pass = true;
    if (validate !== false) {
      var fieldKeys = Object.keys(me.fields);
      fieldKeys.forEach(function (name) {
        var fieldPass = me.fields[name]();
        // if one field fails to pass, the table fails to pass
        if (pass) {
          pass = fieldPass;
        }
      });
    }
    if (me.props.getSavedData) {
      // 滤除可能为空的元素
      var data = deepcopy(me.data);
      data.data = data.data.filter(function (item) {
        return item !== undefined;
      });
      return {
        data: data,
        pass: pass
      };
    }
    return {
      data: me.state.data,
      pass: pass
    };
  };

  Table.prototype.hasFixColumn = function hasFixColumn(props) {
    var columns = props.jsxcolumns.filter(function (item) {
      if (item.fixed) {
        return true;
      }
      return false;
    });
    if (columns.length > 0) {
      return true;
    }
    return false;
  };

  Table.prototype.renderHeader = function renderHeader(renderHeaderProps) {
    if (!this.props.showHeader) {
      return null;
    }

    if (this.hasFixed) {
      return React.createElement(
        'div',
        { className: 'kuma-uxtable-header-wrapper' },
        React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: 'fixed', key: 'grid-header-fixed' })),
        React.createElement(Header, _extends({}, renderHeaderProps, {
          fixedColumn: 'scroll',
          key: 'grid-header-scroll',
          ref: 'headerScroll'
        }))
      );
    }
    return React.createElement(
      'div',
      { className: 'kuma-uxtable-header-wrapper' },
      React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: 'no', ref: 'headerNo' }))
    );
  };

  Table.prototype.renderTbody = function renderTbody(renderBodyProps, bodyHeight) {
    if (this.hasFixed) {
      var fixedBodyProps = assign({}, renderBodyProps, {
        subComp: null
      });
      return React.createElement(
        'div',
        {
          className: 'kuma-uxtable-body-wrapper',
          style: {
            height: bodyHeight
          }
        },
        React.createElement(Tbody, _extends({}, fixedBodyProps, { fixedColumn: 'fixed', key: 'grid-body-fixed', ref: 'bodyFixed' })),
        React.createElement(Tbody, _extends({}, renderBodyProps, {
          fixedColumn: 'scroll',
          key: 'grid-body-scroll',
          onScroll: this.handleBodyScroll
        })),
        React.createElement(Mask, { visible: this.state.showMask, text: this.props.loadingText })
      );
    }
    return React.createElement(
      'div',
      {
        className: 'kuma-uxtable-body-wrapper',
        style: {
          height: bodyHeight
        }
      },
      React.createElement(Tbody, _extends({}, renderBodyProps, { fixedColumn: 'no', onScroll: this.handleBodyScroll })),
      React.createElement(Mask, { visible: this.state.showMask, text: this.props.loadingText })
    );
  };

  /**
   * register CellField to Table for the global validation
   * @param field {element} the cell field to be registered
   */

  Table.prototype.attachCellField = function attachCellField(validate, name) {
    var me = this;
    if (!name) {
      console.error('Table: dataKey can not be undefined, check the column config');
    } else {
      me.fields[name] = validate;
    }
  };

  /**
   * For inline edit
   * receive changes from cell field and change state.data
   * inform users of the change with dataKey & pass
   */

  Table.prototype.handleDataChange = function handleDataChange(obj) {
    var me = this;
    var jsxid = obj.jsxid;
    var column = obj.column;
    var value = obj.value;
    var text = obj.text;
    var pass = obj.pass;

    var dataKey = column.dataKey;
    var editKey = column.editKey || dataKey;
    var data = deepcopy(me.state.data);
    var changedData = {};
    for (var i = 0; i < data.data.length; i++) {
      if (data.data[i].jsxid == jsxid) {
        data.data[i][dataKey] = text;
        data.data[i][editKey] = value;
        changedData = data.data[i];
      }
    }

    me.setState({
      data: data
    }, function () {
      me.props.onChange({
        data: me.state.data,
        editKey: editKey,
        dataKey: dataKey,
        changedData: changedData,
        pass: pass
      });
    });
  };

  Table.prototype.getIsSelectAll = function getIsSelectAll(data) {
    var me = this;
    var column = me.checkboxColumn;
    if (!column || data.length === 0) {
      return false;
    }
    var key = me.checkboxColumnKey;
    var isSelectAll = true;
    for (var i = 0; i < data.length; i++) {
      if ('isDisable' in column && column.isDisable(data[i]) || column.disable) {
        isSelectAll = true;
      } else {
        isSelectAll = data[i][key];
        if (!isSelectAll) {
          break;
        }
      }
    }
    return isSelectAll;
  };

  Table.prototype.render = function render() {
    var _classnames;

    var me = this;
    var props = this.props;
    var state = this.state;

    var bodyHeight = void 0;
    // if table is in sub mode, people always want to align the parent
    // and the sub table, so width should not be cared.
    var headerHeight = props.headerHeight;


    var data = state.data ? state.data.datas || state.data.data : [];
    var isSelectAll = me.getIsSelectAll(data);

    var style = {
      width: props.passedData ? 'auto' : props.width,
      height: props.height
    };
    var actionBarHeight = props.actionBar ? props.actionBarHeight : 0;
    var pagerHeight = props.showPager && this.state.data && this.state.data.totalCount ? 50 : 0;

    // decide whether the table has column groups
    var hasGroup = false;
    for (var i = 0; i < this.state.columns.length; i++) {
      if ('group' in this.state.columns[i]) {
        hasGroup = true;
        break;
      }
    }
    if (props.height === 'auto') {
      bodyHeight = 'auto';
    } else {
      bodyHeight = props.height === '100%' ? props.height : props.height - (headerHeight || (hasGroup ? 80 : 40)) - actionBarHeight - pagerHeight;
    }
    var renderBodyProps = {
      columns: state.columns,
      mask: state.showMask,
      expandedKeys: state.expandedKeys,
      data: data,
      rowSelection: props.rowSelection,
      addRowClassName: props.addRowClassName,
      subComp: props.subComp,
      renderSubComp: props.renderSubComp,
      rowHeight: props.rowHeight,
      loadingText: props.loadingText,
      checkboxColumnKey: me.checkboxColumnKey,
      height: bodyHeight,
      width: props.width,
      mode: props.mode,
      levels: props.levels,
      root: this,
      renderModel: props.renderModel,
      changeSelected: this.changeSelected.bind(this),
      handleDataChange: this.handleDataChange.bind(this),
      attachCellField: this.attachCellField.bind(this),
      detachCellField: this.detachCellField.bind(this),
      key: 'grid-body'
    };
    var renderHeaderProps = {
      columns: state.columns,
      activeColumn: state.activeColumn,
      orderType: state.orderType,
      showColumnPicker: props.showColumnPicker,
      checkboxColumnKey: me.checkboxColumnKey,
      showHeaderBorder: props.showHeaderBorder,
      headerHeight: props.headerHeight,
      renderModel: props.renderModel,
      width: props.width,
      mode: props.mode,
      isSelectAll: isSelectAll,
      selectAll: this.selectAll.bind(this),
      orderColumnCB: this.handleOrderColumnCB.bind(this),
      handleColumnPickerChange: this.handleColumnPickerChange.bind(this),
      key: 'grid-header'
    };

    var actionBar = void 0;

    if (props.actionBar || props.showSearch) {
      var renderActionProps = {
        onSearch: this.handleActionBarSearch.bind(this),
        actionBarConfig: this.props.actionBar,
        showSearch: this.props.showSearch,
        searchBarPlaceholder: this.props.searchBarPlaceholder,
        key: 'grid-actionbar'
      };
      actionBar = React.createElement(ActionBar, renderActionProps);
    }

    return React.createElement(
      'div',
      {
        className: classnames((_classnames = {}, _defineProperty(_classnames, props.className, !!props.className), _defineProperty(_classnames, props.prefixCls, true), _defineProperty(_classnames, 'kuma-subgrid-mode', !!props.passedData), _defineProperty(_classnames, props.prefixCls + '-tree-mode', props.renderModel === 'tree'), _classnames)),
        style: style,
        ref: 'root'
      },
      actionBar,
      React.createElement(
        'div',
        {
          className: 'kuma-uxtable-content',
          style: {
            width: props.passedData ? 'auto' : props.width
          }
        },
        this.renderHeader(renderHeaderProps),
        this.renderTbody(renderBodyProps, bodyHeight)
      ),
      this.renderPager()
    );
  };

  // Util Method

  /**
   * add some specific value for each row data which will be used in manipulating data & rendering.
   * used in record API.
   */

  Table.prototype.addJSXIdsForRecord = function addJSXIdsForRecord(obj) {
    var me = this;
    var objAux = deepcopy(obj);
    if (objAux instanceof Array) {
      objAux = objAux.map(function (item) {
        var newItem = deepcopy(item);
        if (newItem.jsxid === undefined || newItem.jsxid == null) {
          newItem.jsxid = me.uid++;
        }
        if (!newItem.__mode__) {
          newItem.__mode__ = Const.MODE.EDIT;
        }
        return newItem;
      });
    } else {
      objAux.jsxid = me.uid++;
    }
    return objAux;
  };

  /**
   * add some specific value for each row data which will be used in manipulating data & rendering.
   * used in method fetchData
   */

  Table.prototype.addValuesInData = function addValuesInData(objAux) {
    if (!objAux || !objAux.datas && !objAux.data) return null;
    var me = this;
    var data = objAux.datas || objAux.data;
    for (var i = 0; i < data.length; i++) {
      var node = data[i];
      node.jsxid = me.uid++;
      node.__mode__ = node.__mode__ || Const.MODE.VIEW;
      me.addValuesInData(node);
    }
    return objAux;
  };

  /**
   * merge data
   */

  Table.prototype.mergeData = function mergeData(data, obj) {
    var newData = deepcopy(data);
    // code compatible
    if (newData.datas) {
      newData.datas = newData.datas.concat(obj);
    } else if (newData.data) {
      newData.data = newData.data.concat(obj);
    }
    newData.totalCount++;
    return newData;
  };

  /**
   * insert some data into this.state.data
   * @param objAux {Array or Object} datum or data need to be inserted
   */

  Table.prototype.insertRecords = function insertRecords(obj) {
    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') return;
    var me = this;
    var objAux = deepcopy(obj);
    if (!(objAux instanceof Array)) {
      objAux = [objAux];
    }
    objAux = me.addJSXIdsForRecord(objAux);
    me.setState({
      data: me.mergeData(me.state.data, objAux)
    });
  };

  /**
   * update this.state.data using objAux by jsxid
   * @param {object/array} obj
   */


  Table.prototype.updateRecord = function updateRecord(obj, cb) {
    var stateData = deepcopy(this.state.data);

    if (!stateData) {
      return;
    }

    var objAux = deepcopy(obj);
    if (!(objAux instanceof Array)) {
      objAux = [objAux];
    }

    if (stateData.data || stateData.datas) {
      (function () {
        var data = stateData.data || stateData.datas;
        objAux.forEach(function (item) {
          for (var i = 0; i < data.length; i++) {
            if (data[i].jsxid === item.jsxid) {
              data[i] = item;
              break;
            }
          }
        });
        if (stateData.data) {
          stateData.data = data;
        } else if (stateData.datas) {
          stateData.datas = data;
        }
      })();
    }
    this.setState({
      data: stateData
    }, function () {
      if (cb) {
        cb();
      }
    });
  };

  /**
   * update this.state.data & this.data using objAux by jsxid
   * @param {objtct/array} objAux
   */

  Table.prototype.syncRecord = function syncRecord(obj) {
    var me = this;
    var data = me.data.data || me.data.datas;
    var objAux = deepcopy(obj);
    if (!(objAux instanceof Array)) {
      objAux = [objAux];
    }
    me.updateRecord(objAux, function () {
      var stateData = deepcopy(me.state.data.data || me.state.data.datas);
      objAux.forEach(function (item) {
        for (var i = 0; i < stateData.length; i++) {
          var element = stateData[i];
          if (element.jsxid === item.jsxid) {
            data[i] = element;
            break;
          }
        }
      });
    });
  };

  /**
   * remove some items from this.state.data & this.data
   * @param {object/array} obj items to be removed
   */


  Table.prototype.removeRecords = function removeRecords(obj) {
    var me = this;
    var content = deepcopy(me.state.data);
    var data = content.data || content.datas;
    var objAux = deepcopy(obj);
    if (Object.prototype.toString.call(objAux) !== '[object Array]') {
      objAux = [objAux];
    }
    objAux.forEach(function (item) {
      for (var i = 0; i < data.length; i++) {
        var element = data[i];
        if (element.jsxid === item.jsxid) {
          data.splice(i, 1);
          break;
        }
      }
    });
    me.data = content;
    this.setState({
      data: content
    });
  };

  // CURD for Table

  Table.prototype.addEmptyRow = function addEmptyRow() {
    this.insertRecords({});
  };

  Table.prototype.addRow = function addRow(rowData) {
    this.insertRecords(rowData);
  };

  Table.prototype.resetRow = function resetRow(rowData) {
    var me = this;
    var updateData = {};
    var data = me.data.datas || me.data.data;
    for (var i = 0; i < data.length; i++) {
      if (data[i].jsxid === rowData.jsxid) {
        updateData = deepcopy(data[i]);
        break;
      }
    }
    updateData.__mode__ = Const.MODE.EDIT;
    this.updateRecord(updateData);
  };

  Table.prototype.delRow = function delRow(rowData) {
    this.removeRecords(rowData);
  };

  Table.prototype.editRow = function editRow(rowData) {
    var newRowData = deepcopy(rowData);
    newRowData.__mode__ = Const.MODE.EDIT;
    this.updateRecord(newRowData);
  };

  Table.prototype.viewRow = function viewRow(rowData) {
    var newRowData = deepcopy(rowData);
    newRowData.__mode__ = Const.MODE.VIEW;
    this.updateRecord(newRowData);
  };

  Table.prototype.saveRow = function saveRow(rowData) {
    var newRowData = deepcopy(rowData);
    newRowData.__mode__ = Const.MODE.VIEW;
    newRowData.__edited__ = true;
    this.syncRecord(newRowData);
  };

  Table.prototype.saveAllRow = function saveAllRow() {
    var me = this;
    var data = deepcopy(me.state.data.data || me.state.data.datas);
    data.forEach(function (item) {
      me.saveRow(item);
    });
    for (var i = 0; i < data.length; i++) {
      var item = data[i];
      item.__mode__ = Const.MODE.VIEW;
      item.__edited__ = true;
    }
    this.syncRecord(data);
  };

  Table.prototype.editAllRow = function editAllRow() {
    var me = this;
    var data = deepcopy(me.data.data || me.data.datas);
    for (var i = 0; i < data.length; i++) {
      var item = data[i];
      item.__mode__ = Const.MODE.EDIT;
    }
    this.updateRecord(data);
  };

  Table.prototype.toggleSubComp = function toggleSubComp(rowData) {
    var content = deepcopy(this.state.data);
    var data = content.data || content.datas;

    if (data) {
      for (var i = 0; i < data.length; i++) {
        var item = data[i];
        if (item.jsxid === rowData.jsxid) {
          item.showSubComp = !item.showSubComp;
          break;
        }
      }
      this.setState({
        data: content
      });
    }
  };

  Table.prototype.toggleTreeExpanded = function toggleTreeExpanded(rowData) {
    var expandedKeys = deepcopy(this.state.expandedKeys);
    util.toggleItemInArr(rowData.jsxid, expandedKeys);
    this.setState({
      expandedKeys: expandedKeys
    });
  };

  return Table;
}(React.Component);

Table.defaultProps = {
  prefixCls: 'kuma-uxtable',
  locale: 'zh-cn',
  showHeader: true,
  width: 'auto',
  height: 'auto',
  mode: Const.MODE.EDIT,
  renderModel: '',
  levels: 1,
  actionBarHeight: 40,
  fetchDataOnMount: true,
  doubleClickToEdit: true,
  rowSelector: 'checkboxSelector',
  showPager: true,
  isMiniPager: true,
  showPagerSizeChanger: true,
  showColumnPicker: true,
  showHeaderBorder: false,
  showPagerTotal: false,
  showMask: false,
  showSearch: false,
  getSavedData: true,
  pageSize: 10,
  pagerSizeOptions: [10, 20, 30, 40],
  rowHeight: 76,
  fetchParams: {},
  currentPage: 1,
  queryKeys: [],
  emptyText: '暂无数据',
  searchBarPlaceholder: '搜索表格内容',
  loadingText: 'loading',
  fitResponse: function fitResponse(response) {
    return {
      content: response.content,
      success: response.success === undefined ? !response.hasError : response.success,
      error: {
        message: response.content || response.errors
      }
    };
  },
  processData: function processData(data) {
    return data;
  },
  beforeFetch: function beforeFetch(obj) {
    return obj;
  },
  onFetchError: function onFetchError(err) {
    console.error(err.stack);
  },
  addRowClassName: function addRowClassName() {},
  onChange: function onChange() {}
};

// http://facebook.github.io/react/docs/reusable-components.html
Table.propTypes = {
  /**
   * @title 国际化
   */
  locale: React.PropTypes.string,
  /**
   * @title 列配置
   */
  jsxcolumns: React.PropTypes.arrayOf(React.PropTypes.object),
  /**
   * @title 表格宽度
   */
  width: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
  /**
   * @title 表格高度
   */
  height: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
  /**
   * @title 表头高度
   */
  headerHeight: React.PropTypes.number,
  /**
   * @title 每页显示条数
   */
  pageSize: React.PropTypes.number,
  /**
   * @title 哪些参数传递给 subComp (即将废除)
   */
  queryKeys: React.PropTypes.array,
  /**
   * @title 是否在初始化时请求数据
   */
  fetchDataOnMount: React.PropTypes.bool,
  /**
   * @title 是否双击进入编辑模式
   */
  doubleClickToEdit: React.PropTypes.bool,
  /**
   * @title 是否显示列选择器
   */
  showColumnPicker: React.PropTypes.bool,
  /**
   * @title 是否显示分页
   */
  showPager: React.PropTypes.bool,
  /**
   * @title 分页中是否显示总条数
   */
  showPagerTotal: React.PropTypes.bool,
  /**
   * @title  显示的可选 pageSize
   */
  pagerSizeOptions: React.PropTypes.array,
  /**
   * @title 是否显示表格头
   */
  showHeader: React.PropTypes.bool,
  /**
   * @title 是否显示遮罩
   */
  showMask: React.PropTypes.bool,
  /**
   * @title 是否显示搜索框
   */
  showSearch: React.PropTypes.bool,
  /**
   * @title 搜索框占位符
   */
  searchBarPlaceholder: React.PropTypes.string,
  /**
   * @title 加载中文案
   */
  loadingText: React.PropTypes.string,
  /**
   * @title 子组件(即将废除)
   */
  subComp: React.PropTypes.element,
  /**
   * @title 无数据时的文案
   */
  emptyText: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.element]),
  /**
   * @title 数据源（手动）
   */
  jsxdata: React.PropTypes.object,
  /**
   * @title 数据源（url）
   */
  fetchUrl: React.PropTypes.string,
  /**
   * @title 请求携带的参数
   */
  fetchParams: React.PropTypes.object,
  /**
   * @title 当前页数
   */
  currentPage: React.PropTypes.number,
  /**
   * @title 列选择器的类型
   */
  rowSelector: React.PropTypes.string,
  /**
   * @title 操作栏配置
   */
  actionBar: React.PropTypes.oneOfType([React.PropTypes.array, React.PropTypes.object]),
  fitResponse: React.PropTypes.func,
  /**
   * @title 处理数据的回调
   */
  processData: React.PropTypes.func,
  /**
   * @title 发起请求前的回调
   */
  beforeFetch: React.PropTypes.func,
  /**
   * @title 请求出错时的回调
   */
  onFetchError: React.PropTypes.func,
  /**
   * @title 渲染每一行前用于添加特殊类名的回调
   */
  addRowClassName: React.PropTypes.func,
  /**
   */
  passedData: React.PropTypes.object,
  /**
   * @title getData 获取的是否是保存之后的数据
   */
  getSavedData: React.PropTypes.bool,
  /**
   * @title 行内编辑时触发的回调
   */
  onChange: React.PropTypes.func,
  /**
   * @title 是否是树模式
   */
  renderModel: React.PropTypes.string,
  /**
   * @title 树的层级
   */
  levels: React.PropTypes.number
};

Table.displayName = 'Table';
Table.CellField = CellField;
Table.Constants = Const;

module.exports = Table;