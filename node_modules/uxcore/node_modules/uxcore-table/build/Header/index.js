'use strict';

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Created by xy on 15/4/13.
 */
var CheckBox = require('../Cell/CheckBox');
var assign = require('object-assign');
var Const = require('uxcore-const');
var Menu = require('uxcore-menu');
var Dropdown = require('uxcore-dropdown');
var Tooltip = require('uxcore-tooltip');
var classnames = require('classnames');
var React = require('react');
var ReactDOM = require('react-dom');

var Header = function (_React$Component) {
    _inherits(Header, _React$Component);

    function Header(props) {
        _classCallCheck(this, Header);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        _this.state = {
            pickerDisplay: false
        };
        return _this;
    }

    Header.prototype.getDomNode = function getDomNode() {
        return this.refs.root;
    };

    Header.prototype.handleCheckBoxChange = function handleCheckBoxChange() {
        var v = this.refs.checkbox.getValue();
        this.props.selectAll.apply(null, [v]);
    };

    Header.prototype.handlePickerSelect = function handlePickerSelect(info) {
        this.props.handleColumnPickerChange(info.selectedKeys);
    };

    Header.prototype.handlePickerDeselect = function handlePickerDeselect(info) {
        this.props.handleColumnPickerChange(info.selectedKeys);
    };

    Header.prototype.handlePickerVisibleChange = function handlePickerVisibleChange(visible) {
        this.setState({
            pickerDisplay: visible
        });
    };

    Header.prototype.handleColumnOrder = function handleColumnOrder(column) {
        var me = this;
        var _me$props = me.props;
        var orderColumnCB = _me$props.orderColumnCB;
        var activeColumn = _me$props.activeColumn;
        var orderType = _me$props.orderType;

        var type = 'desc';
        var typeMap = {
            desc: 'asc',
            asc: 'none',
            none: 'desc'
        };
        if (activeColumn && column.dataKey == activeColumn.dataKey && orderType) {
            type = typeMap[orderType];
        }
        orderColumnCB && orderColumnCB(type, column);
    };

    Header.prototype.getSelectedKeys = function getSelectedKeys() {
        var me = this;
        var columns = me.props.columns;

        var _columns = [];
        var selectedKeys = [];
        columns.forEach(function (item, index) {
            if ('group' in item) {
                _columns = _columns.concat(item.columns);
            } else {
                _columns.push(item);
            }
        });
        _columns.forEach(function (item, index) {
            if (!item.hidden) {
                selectedKeys.push(item.dataKey);
            }
        });
        return selectedKeys;
    };

    Header.prototype.renderColumnSelect = function renderColumnSelect() {
        var me = this;
        var columns = me.props.columns;

        var notRenderColumns = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];
        notRenderColumns.push(me.props.checkboxColumnKey);
        var options = [];
        columns.forEach(function (item, index) {
            if (notRenderColumns.indexOf(item.dataKey) == -1) {
                if (item.dataKey) {
                    options.push(React.createElement(
                        Menu.Item,
                        { key: item.dataKey },
                        item.title
                    ));
                }
            }
        });
        return React.createElement(
            Menu,
            { multiple: true, selectedKeys: me.getSelectedKeys(), onSelect: me.handlePickerSelect.bind(me), onDeselect: me.handlePickerDeselect.bind(me) },
            options
        );
    };

    Header.prototype.renderPicker = function renderPicker() {
        var me = this;
        var pickerDisplay = me.state.pickerDisplay;


        var dropdownAlign = {
            bottomRight: {
                points: ['br', 'tr'],
                overflow: {
                    adjustX: 1,
                    adjustY: 1
                },
                offset: [0, -4],
                targetOffset: [0, 0]
            }
        };

        return React.createElement(
            'div',
            { className: classnames({
                    "kuma-column-picker-container": true,
                    "hasGroup": me.hasGroup
                }) },
            React.createElement(
                Dropdown,
                { trigger: ['click'], overlay: me.renderColumnSelect(), visible: pickerDisplay, overlayClassName: 'kuma-uxtable-column-picker-dropdown',
                    align: dropdownAlign, onVisibleChange: me.handlePickerVisibleChange.bind(me) },
                React.createElement('i', { className: 'kuma-icon kuma-icon-target-list kuma-column-picker' })
            )
        );
    };

    Header.prototype.renderOrderIcon = function renderOrderIcon(column) {
        var me = this;
        var _me$props2 = me.props;
        var orderType = _me$props2.orderType;
        var activeColumn = _me$props2.activeColumn;

        if (column.ordered) {
            var _classnames, _classnames2;

            var desc = "iconfontdown",
                asc = "iconfontup";
            return React.createElement(
                'span',
                { className: 'kuma-uxtable-h-sort', onClick: me.handleColumnOrder.bind(me, column) },
                React.createElement('i', { className: classnames((_classnames = {}, _defineProperty(_classnames, 'kuma-icon kuma-icon-' + asc, true), _defineProperty(_classnames, 'active', activeColumn && activeColumn.dataKey === column.dataKey && orderType == 'asc'), _classnames)) }),
                React.createElement('i', { className: classnames((_classnames2 = {}, _defineProperty(_classnames2, 'kuma-icon kuma-icon-' + desc, true), _defineProperty(_classnames2, 'active', activeColumn && activeColumn.dataKey === column.dataKey && orderType == 'desc'), _classnames2)) })
            );
        }
    };

    Header.prototype.renderMessageIcon = function renderMessageIcon(column) {
        if (!column.message) return;
        return React.createElement(
            Tooltip,
            { overlay: React.createElement(
                    'div',
                    { className: 'kuma-uxtable-column-message' },
                    column.message
                ) },
            React.createElement('i', { className: 'kuma-icon kuma-icon-information' })
        );
    };

    Header.prototype.renderColumn = function renderColumn(item, index, hasGroup, last) {
        var me = this;
        var _me$props3 = me.props;
        var data = _me$props3.data;
        var renderModel = _me$props3.renderModel;

        var rowSelectorInTreeMode = ['checkboxSelector', 'radioSelector'].indexOf(item.type) !== -1 && renderModel == 'tree';
        if (item.hidden || rowSelectorInTreeMode) {
            me.firstIndex = index + 1;
            return;
        }
        var noBorderColumn = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];
        var _style = {
            width: item.width ? item.width : 100,
            textAlign: item.align ? item.align : "left"
        };
        var _v = void 0;

        if (hasGroup) {
            assign(_style, {
                height: 100,
                lineHeight: 100 + 'px'
            });
        }

        if (item.type == 'checkbox' || item.type == 'checkboxSelector') {
            assign(_style, {
                paddingRight: 4,
                paddingLeft: 12,
                width: item.width ? item.width : 92
            });

            var checkBoxProps = {
                ref: 'checkbox',
                checked: me.props.isSelectAll,
                disable: me.props.mode !== Const.MODE.VIEW ? item.disable : true,
                onChange: me.handleCheckBoxChange.bind(me)
            };

            _v = React.createElement(CheckBox, checkBoxProps);
        } else {
            var content = typeof item.title === 'function' ? item.title() : item.title;
            var title = typeof item.title === 'function' ? undefined : item.title;
            _v = React.createElement(
                'span',
                { title: title },
                content
            );
        }

        if (noBorderColumn.indexOf(item.dataKey) !== -1 || last) {
            assign(_style, {
                borderRight: 'none'
            });
        }

        return React.createElement(
            'div',
            {
                key: index,
                className: classnames({
                    "kuma-uxtable-cell": true,
                    "show-border": me.props.showHeaderBorder
                }),
                style: _style
            },
            me.renderIndent(index),
            _v,
            me.renderMessageIcon(item),
            me.renderOrderIcon(item)
        );
    };

    Header.prototype.renderIndent = function renderIndent(index) {
        if (this.firstIndex !== index) {
            return;
        }
        var me = this;
        var _me$props4 = me.props;
        var renderModel = _me$props4.renderModel;
        var checkboxColumnKey = _me$props4.checkboxColumnKey;

        if (renderModel == "tree") {
            return React.createElement('span', { className: classnames({
                    "indent": true,
                    "hasCheck": checkboxColumnKey
                }) });
        }
    };

    Header.prototype.renderColumns = function renderColumns(_columns) {
        var me = this;
        var columns = _columns.map(function (item, index) {
            var last = index == _columns.length - 1;
            if ('group' in item) {
                // First determine whether the group should be rendered, if all columns
                // is hidden, the column group should not be rendered.
                var shouldRenderGroup = item.columns.some(function (column, i) {
                    return !column.hidden;
                });
                if (shouldRenderGroup) {
                    return React.createElement(
                        'div',
                        { className: 'kuma-uxtable-header-column-group', key: index },
                        React.createElement(
                            'div',
                            { className: 'kuma-uxtable-header-group-name' },
                            item.group
                        ),
                        item.columns.map(function (column, i) {
                            return me.renderColumn(column, i, false, last);
                        })
                    );
                }
            } else {
                return me.renderColumn(item, index, me.hasGroup, last);
            }
        });
        return columns;
    };

    Header.prototype.render = function render() {
        var props = this.props,
            me = this,
            _picker = void 0,
            _width = 0,
            headerWrapClassName = void 0,
            _headerStyle = {},
            _columns = void 0;

        if (props.showColumnPicker && (props.fixedColumn == 'no' || props.fixedColumn == 'scroll')) {
            _picker = this.renderPicker();
        }

        if (props.fixedColumn == 'fixed') {
            _columns = props.columns.filter(function (item) {
                if (item.fixed && !item.hidden) {
                    if (!item.width) {
                        item.width = 100;
                    }
                    _width = item.width * 1 + _width;
                    return true;
                }
            });
            assign(_headerStyle, {
                width: _width,
                minWidth: _width
            });
            headerWrapClassName = "kuma-uxtable-header-fixed";
        } else if (props.fixedColumn == 'scroll') {
            _columns = props.columns.filter(function (item) {
                if (!item.fixed) {
                    return true;
                } else if (!item.hidden) {
                    if (!item.width) {
                        item.width = 100;
                    }
                    _width = item.width * 1 + _width;
                }
            });
            assign(_headerStyle, {
                width: props.width - _width - 3,
                minWidth: props.width - _width - 3
            });
            headerWrapClassName = "kuma-uxtable-header-scroll";
        } else {
            _columns = props.columns;
            headerWrapClassName = "kuma-uxtable-header-no";
        }
        me.hasGroup = false;
        for (var i = 0; i < _columns.length; i++) {
            if ('group' in _columns[i]) {
                me.hasGroup = true;
                break;
            }
        }
        assign(_headerStyle, {
            height: props.headerHeight ? props.headerHeight : me.hasGroup ? 100 : 50,
            lineHeight: (props.headerHeight ? props.headerHeight : 50) + "px"
        });
        return React.createElement(
            'div',
            { className: headerWrapClassName, style: _headerStyle, ref: 'root' },
            React.createElement(
                'div',
                { className: props.jsxprefixCls },
                me.renderColumns(_columns),
                _picker
            )
        );
    };

    return Header;
}(React.Component);

;

Header.propTypes = {};

Header.defaultProps = {
    jsxprefixCls: "kuma-uxtable-header"
};

module.exports = Header;