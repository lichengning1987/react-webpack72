'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * DateFormField Component for uxcore
 * @author eternalsky
 *
 * Copyright 2015-2016, Uxcore Team, Alinw.
 * All rights reserved.
 */

var React = require('react');
var FormField = require('uxcore-form-field');
var Constants = require('uxcore-const');
var classnames = require('classnames');
var Calendar = require('uxcore-calendar');
var assign = require('object-assign');
var deepcopy = require('deepcopy');
var Formatter = require('uxcore-formatter');
var CalendarPanel = {
    month: Calendar.MonthCalendar,
    year: Calendar.YearCalendar,
    day: Calendar
};

var DateFormField = function (_FormField) {
    _inherits(DateFormField, _FormField);

    function DateFormField(props) {
        _classCallCheck(this, DateFormField);

        return _possibleConstructorReturn(this, _FormField.call(this, props));
    }

    DateFormField.prototype.handleChange = function handleChange(value, format) {
        var me = this;
        var useFormat = me.props.useFormat;

        var data = void 0;
        if (useFormat) {
            data = format;
        } else {
            data = value ? new Date(value).getTime() : null;
        }
        me.handleDataChange(data);
    };

    DateFormField.prototype.handleCascadeChange = function handleCascadeChange(i, value, format) {
        var me = this;
        var values = deepcopy(me.state.value) || [];
        var useFormat = me.props.useFormat;

        var data = void 0;
        if (useFormat) {
            data = format;
        } else {
            data = value ? new Date(value).getTime() : undefined;
        }
        values[i] = data;
        if (value) {
            if (i == 0 && !!values[1] && new Date(value).getTime() > new Date(values[1]).getTime()) {
                values.pop();
            }
            if (i == 1 && !!values[0] && new Date(value).getTime() < new Date(values[0]).getTime()) {
                values[0] = undefined;
            }
        }
        me.handleDataChange(values);
    };

    DateFormField.prototype.addSpecificClass = function addSpecificClass() {
        var me = this;
        if (me.props.jsxprefixCls == "kuma-uxform-field") {
            var str = me.props.jsxprefixCls + " kuma-date-uxform-field";
            if (me.props.jsxtype == "cascade") {
                str += " kuma-cascade-date-uxform-field";
            }
            return str;
        } else {
            return me.props.jsxprefixCls;
        }
    };

    DateFormField.prototype.processTime = function processTime(time) {
        // if showTime is true or timePicker is set, we use time to compare
        // otherwise we use day to compare
        var me = this;
        var _me$props = me.props;
        var showTime = _me$props.showTime;
        var timePicker = _me$props.timePicker;

        if (showTime || timePicker) {
            return new Date(time).getTime();
        } else {
            return new Date(Formatter.date(time, 'YYYY-MM-DD')).getTime();
        }
    };

    DateFormField.prototype.renderField = function renderField() {
        var me = this;
        var _me$props2 = me.props;
        var onSelect = _me$props2.onSelect;
        var style = _me$props2.style;
        var prefixCls = _me$props2.prefixCls;
        var value = _me$props2.value;
        var jsxtype = _me$props2.jsxtype;
        var jsxfrom = _me$props2.jsxfrom;
        var jsxto = _me$props2.jsxto;
        var disabledDate = _me$props2.disabledDate;
        var panel = _me$props2.panel;

        var others = _objectWithoutProperties(_me$props2, ['onSelect', 'style', 'prefixCls', 'value', 'jsxtype', 'jsxfrom', 'jsxto', 'disabledDate', 'panel']);

        var from = !!jsxfrom ? me.processTime(jsxfrom) : -Infinity;
        var to = !!jsxto ? me.processTime(jsxto) : Infinity;
        var mode = me.props.jsxmode || me.props.mode;
        if (mode == Constants.MODE.EDIT) {
            var Panel = CalendarPanel[panel];
            if (jsxtype == "single") {
                return React.createElement(Panel, _extends({
                    value: me.state.value,
                    onSelect: me.handleChange.bind(me),
                    disabledDate: disabledDate ? disabledDate : function (current, value) {
                        // if showTime is true or timePicker is set, we use time to compare
                        // otherwise we use day to compare
                        if (!current) {
                            return false;
                        }

                        return me.processTime(current.getTime()) < from || me.processTime(current.getTime()) > to;
                    }
                }, others));
            } else if (jsxtype == "cascade") {
                var arr = [];
                var others1 = assign({}, others);
                var others2 = assign({}, others);
                if (me.state.value && me.state.value[0]) {
                    others1 = assign({}, others, {
                        value: me.state.value[0]
                    });
                } else {
                    others1 = assign({}, others, {
                        value: null
                    });
                }
                if (me.state.value && me.state.value[1]) {
                    others2 = assign({}, others, {
                        value: me.state.value[1]
                    });
                } else {
                    others2 = assign({}, others, {
                        value: null
                    });
                }
                arr.push(React.createElement(Panel, _extends({
                    key: 'calendar1',
                    onSelect: me.handleCascadeChange.bind(me, 0),
                    disabledDate: function disabledDate(current, value) {
                        if (!current) {
                            return false;
                        }
                        var now = me.processTime(current.getTime());
                        return now < from || now > to;
                    }
                }, others1)));
                arr.push(React.createElement(
                    'span',
                    { key: 'split', className: 'kuma-uxform-split' },
                    '-'
                ));

                arr.push(React.createElement(Panel, _extends({
                    key: 'calendar2',
                    onSelect: me.handleCascadeChange.bind(me, 1),
                    disabledDate: function disabledDate(current, value) {
                        if (!current) {
                            return false;
                        }
                        var now = me.processTime(current.getTime());
                        var first = me.state.value ? me.state.value[0] : 0;
                        first = me.processTime(first);
                        return now < from || now > to || now < first;
                    }
                }, others2)));
                return arr;
            }
        } else if (mode == Constants.MODE.VIEW) {
            var _ret = function () {
                var defautFormat = 'YYYY-MM-DD';
                if (me.props.showTime || me.props.timePicker) {
                    defautFormat = 'YYYY-MM-DD HH:mm:ss';
                }
                if (jsxtype == "single") {
                    return {
                        v: React.createElement(
                            'span',
                            null,
                            !!me.state.value ? Formatter.date(me.state.value, me.props.format || defautFormat) : ""
                        )
                    };
                } else {
                    return {
                        v: React.createElement(
                            'span',
                            null,
                            !!me.state.value ? me.state.value.map(function (item) {
                                return Formatter.date(item, me.props.format || defautFormat);
                            }).join(" - ") : ""
                        )
                    };
                }
            }();

            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
        }
    };

    return DateFormField;
}(FormField);

DateFormField.displayName = "DateFormField";
DateFormField.propTypes = assign(FormField.propTypes, {
    jsxtype: React.PropTypes.string,
    panel: React.PropTypes.string,
    useFormat: React.PropTypes.bool
});
DateFormField.defaultProps = assign(FormField.defaultProps, {
    locale: 'zh-cn',
    hasTrigger: true,
    jsxtype: 'single',
    panel: 'day',
    useFormat: false
});
module.exports = DateFormField;