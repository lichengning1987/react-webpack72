'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var React = require('react');
var Constants = require('uxcore-const');
var classnames = require('classnames');
var assign = require('object-assign');
var deepequal = require('deep-equal');

var FormField = function (_React$Component) {
  _inherits(FormField, _React$Component);

  function FormField(props) {
    _classCallCheck(this, FormField);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.state = {
      value: props.value,
      formatValue: _this.formatValue(props.value),
      error: false,
      errMsg: ''
    };
    return _this;
  }

  FormField.prototype.componentDidMount = function componentDidMount() {
    var me = this;
    if (!me.props.standalone) {
      me.props.attachFormField(me);
      me.props.handleDataChange(me, {
        value: me.props.value,
        pass: true
      }, true);
    }
  };

  FormField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var me = this;
    if (!me.isEqual(nextProps.value, me.props.value)) {
      me.handleDataChange(nextProps.value, true, true);
    }
  };

  FormField.prototype.componentWillUnmount = function componentWillUnmount() {
    var me = this;
    if (!me.props.standalone) {
      this.props.detachFormField(this);
    }
  };

  FormField.prototype.getProps = function getProps() {
    return this.props;
  };

  FormField.prototype.getLabelNode = function getLabelNode() {
    return this.refs.label;
  };

  FormField.prototype.getTipsNode = function getTipsNode() {
    return this.refs.tips;
  };

  FormField.prototype.getRequiredNode = function getRequiredNode() {
    return this.refs.required;
  };

  FormField.prototype.getErrorNode = function getErrorNode() {
    return this.refs.error;
  };

  FormField.prototype.getName = function getName() {
    return this.props.jsxname;
  };

  FormField.prototype.getValue = function getValue() {
    return this.formatValue(this.state.value);
  };

  FormField.prototype.setValue = function setValue(value, fromReset, next) {
    var me = this;
    me.setState({
      value: value,
      formatValue: me.formatValue(value),
      error: !!fromReset ? false : me.state.error,
      /*
       * why set state fromReset? some field like editor cannot be reset in the common way
       * so set this state to tell the field that you need to reset by yourself.
       */
      fromReset: !!fromReset
    }, function () {
      if (next && typeof next === 'function') {
        next();
      }
    });
  };

  /**
   * selectFormField depends on this method
   */


  FormField.prototype._isEqual = function _isEqual(a, b) {
    return deepequal(a, b);
  };

  /*
   * Fired when field value changes，update form's state and then trigger re-render.
   * @param fromReset {boolean} if handleDataChange is invoked by form's resetValues,
   */

  FormField.prototype.handleDataChange = function handleDataChange(value, fromReset, silence) {
    var me = this;
    me.setValue(value, fromReset, function () {
      var pass = true;
      // validateOnBlur only support InputFormField & TextAraeFormField now
      if (!fromReset && !me.props.standalone && !me.props.validateOnBlur) {
        pass = me.doValidate();
      }
      if (!!me.props.handleDataChange) {
        me.props.handleDataChange(me, {
          value: value,
          pass: pass
        }, silence);
      }
    });
  };

  /**
   * @return {boolean} if validate pass, return true, or, return false
   * if no rule, it means validate pass.
   */

  FormField.prototype.doValidate = function doValidate(force, always) {
    var me = this;
    var instant = true;
    if ('instantValidate' in me.props) {
      instant = me.props.instantValidate;
    } else {
      instant = me.props.jsxinstant;
    }
    // `force` has the top priority, `undefined` is not equal to `false`
    // `instant` has the sceond priority here
    // eternalsky@2016.03.15
    if (force === true || force !== false && instant) {
      if (me.props.jsxrules) {
        var error = me.isDirty(always);
        me.setState({
          error: error.isDirty,
          errMsg: error.errMsg
        });
        return !error.isDirty;
      }
      return true;
    }
    return true;
  };

  /*
   * rule can be an object, containing errMsg & validator,
   * and rule can also be an array containing such objects.
   * this func will check them one by one, and return false
   * unless all rules pass
   */

  FormField.prototype.isDirty = function isDirty(always) {
    var me = this;
    var rules = me.props.jsxrules;
    var isDirty = false;
    var errMsg = '';
    if ((typeof rules === 'undefined' ? 'undefined' : _typeof(rules)) === 'object' && !Array.isArray(rules)) {
      isDirty = always === undefined ? !rules.validator(me.state.value) : !always;
      errMsg = rules.errMsg;
    } else if (Array.isArray(rules)) {
      for (var i = 0; i < rules.length; i++) {
        isDirty = always === undefined ? !rules[i].validator(me.state.value) : !always;
        if (isDirty) {
          errMsg = rules[i].errMsg;
          break;
        }
      }
    }
    return {
      isDirty: isDirty,
      errMsg: errMsg
    };
  };

  FormField.prototype.isEqual = function isEqual(a, b) {
    return deepequal(a, b);
  };

  FormField.prototype.addSpecificClass = function addSpecificClass() {
    return this.props.jsxprefixCls;
  };

  /*
   * You should rewrite this method，when you need to format the value as you concern.
   */

  FormField.prototype.formatValue = function formatValue(value) {
    return value;
  };

  FormField.prototype.renderTips = function renderTips() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    if (mode !== Constants.MODE.EDIT) return null;
    if (me.props.standalone && me.props.message && me.props.message.type === 'tip') {
      return React.createElement(
        'li',
        { className: 'kuma-uxform-tips' },
        React.createElement('i', { className: 'kuma-icon kuma-icon-information' }),
        React.createElement(
          'span',
          { ref: 'tips' },
          me.props.message.message
        )
      );
    }
    if (!!this.props.jsxtips && !me.state.error) {
      return React.createElement(
        'li',
        { className: 'kuma-uxform-tips' },
        React.createElement('i', { className: 'kuma-icon kuma-icon-information' }),
        React.createElement(
          'span',
          { ref: 'tips' },
          this.props.jsxtips
        )
      );
    }
    return null;
  };

  /*
   * You should rewrite this method, when you are developing a new type of form field.
   */

  FormField.prototype.renderField = function renderField() {};

  FormField.prototype.renderErrorMsg = function renderErrorMsg() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    if (mode !== Constants.MODE.EDIT) return null;
    if (me.props.standalone && me.props.message && me.props.message.type === 'error') {
      return React.createElement(
        'li',
        { className: 'kuma-uxform-errormsg' },
        React.createElement('i', { className: 'kuma-icon kuma-icon-error' }),
        React.createElement(
          'span',
          { ref: 'error' },
          me.props.message.message
        )
      );
    }
    if (!!me.state.error) {
      return React.createElement(
        'li',
        { className: 'kuma-uxform-errormsg' },
        React.createElement('i', { className: 'kuma-icon kuma-icon-error' }),
        React.createElement(
          'span',
          { ref: 'error' },
          me.state.errMsg
        )
      );
    }
    return null;
  };

  FormField.prototype.renderLabel = function renderLabel() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    // jsxVerticalAlign is an internal varible.
    var align = me.props.verticalAlign || me.props.jsxVerticalAlign;
    if (me.props.jsxshowLabel) {
      return React.createElement(
        'label',
        {
          key: 'label',
          className: classnames({
            'kuma-label': true,
            'vertical-align': align,
            'label-match-input-height': me.props.labelMatchInputHeight
          })
        },
        React.createElement(
          'span',
          { className: 'required', ref: 'required' },
          me.props.required && mode === Constants.MODE.EDIT ? '* ' : ''
        ),
        React.createElement('span', {
          className: 'label-content',
          ref: 'label',
          dangerouslySetInnerHTML: {
            __html: me.props.jsxlabel
          }
        })
      );
    }
    return null;
  };

  FormField.prototype.renderContent = function renderContent() {
    var me = this;
    var mode = me.props.jsxmode || me.props.mode;
    var align = me.props.verticalAlign || me.props.jsxVerticalAlign;
    if (me.props.labelMatchInputHeight) {
      return [React.createElement(
        'div',
        {
          key: 'content',
          style: {
            display: 'table'
          }
        },
        me.renderLabel(),
        React.createElement(
          'ul',
          {
            className: classnames({
              'kuma-uxform-field-content': true,
              'view-mode': mode === Constants.MODE.VIEW,
              'edit-mode': mode === Constants.MODE.EDIT,
              'has-error': !!me.state.error
            })
          },
          React.createElement(
            'li',
            { className: 'kuma-uxform-field-core' },
            me.renderField()
          )
        )
      ), React.createElement(
        'div',
        {
          key: 'tip',
          className: 'kuma-uxform-tip-box',
          style: {
            display: 'table'
          }
        },
        !align ? React.createElement('label', {
          className: classnames({
            'kuma-label': true
          })
        }) : null,
        React.createElement(
          'ul',
          null,
          me.renderTips(),
          me.renderErrorMsg()
        )
      )];
    }
    return [me.renderLabel(), React.createElement(
      'ul',
      {
        key: 'content',
        className: classnames({
          'kuma-uxform-field-content': true,
          'view-mode': mode === Constants.MODE.VIEW,
          'edit-mode': mode === Constants.MODE.EDIT,
          'has-error': !!me.state.error
        })
      },
      React.createElement(
        'li',
        { key: 'core', className: 'kuma-uxform-field-core' },
        me.renderField()
      ),
      me.renderTips(),
      me.renderErrorMsg()
    )];
  };

  FormField.prototype.render = function render() {
    var _classnames;

    var me = this;
    var specificCls = me.addSpecificClass();
    var style = {};
    if (!me.props.standalone) {
      style.width = me.props.jsxflex / me.props.totalFlex * 100 + '%';
    }
    return React.createElement(
      'div',
      {
        className: classnames((_classnames = {}, _defineProperty(_classnames, specificCls, true), _defineProperty(_classnames, me.props.className, !!me.props.className), _classnames)),
        style: assign({}, style, {
          display: me.props.jsxshow ? 'table' : 'none'
        })
      },
      me.renderContent()
    );
  };

  return FormField;
}(React.Component);

FormField.propTypes = {
  instantValidate: React.PropTypes.bool,
  verticalAlign: React.PropTypes.bool,
  labelMatchInputHeight: React.PropTypes.bool,
  detachFormField: React.PropTypes.func,
  value: React.PropTypes.any,
  jsxshow: React.PropTypes.bool,
  jsxmode: React.PropTypes.string,
  jsxshowLabel: React.PropTypes.bool,
  jsxprefixCls: React.PropTypes.string,
  jsxflex: React.PropTypes.number,
  jsxname: React.PropTypes.string.isRequired,
  jsxplaceholder: React.PropTypes.string,
  jsxlabel: React.PropTypes.string,
  jsxtips: React.PropTypes.string,
  jsxrules: React.PropTypes.oneOfType([React.PropTypes.object, React.PropTypes.array]),
  totalFlex: React.PropTypes.number,
  standalone: React.PropTypes.bool,
  required: React.PropTypes.bool
};

FormField.defaultProps = {
  verticalAlign: false,
  labelMatchInputHeight: false,
  jsxshow: true,
  jsxshowLabel: true,
  jsxprefixCls: 'kuma-uxform-field',
  jsxflex: 1,
  jsxname: '',
  jsxplaceholder: '',
  jsxlabel: '',
  jsxtips: '',
  standalone: false,
  mode: Constants.MODE.EDIT,
  required: false
};

FormField.displayName = 'FormField';

module.exports = FormField;