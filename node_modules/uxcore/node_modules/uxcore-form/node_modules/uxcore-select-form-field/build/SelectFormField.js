'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Created by xy on 15/4/13.
 */
var React = require('react');
var FormField = require('uxcore-form-field');
var Constants = require('uxcore-const');
var Select = require('uxcore-select2');
var assign = require('object-assign');
var Validator = require('uxcore-validator');
var isEqual = require('lodash/isEqual');
var NattyFetch = require('natty-fetch/dist/natty-fetch.pc');
var Promise = require('lie');

var isArray = Validator.isArray;
var Option = Select.Option;

var selectOptions = ['onSelect', 'onDeselect', 'getPopupContainer', 'multiple', 'filterOption', 'allowClear', 'combobox', 'searchPlaceholder', 'tags', 'disabled', 'showSearch', 'placeholder', 'optionLabelProp', 'maxTagTextLength', 'dropdownMatchSelectWidth', 'dropdownClassName', 'notFoundContent', 'labelInValue'];

var SelectFormField = function (_FormField) {
  _inherits(SelectFormField, _FormField);

  function SelectFormField(props) {
    _classCallCheck(this, SelectFormField);

    var _this = _possibleConstructorReturn(this, _FormField.call(this, props));

    var me = _this;
    assign(me.state, {
      data: me.processData(props.jsxdata)
    });
    return _this;
  }

  SelectFormField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var me = this;
    if (!isEqual(nextProps.value, me.props.value)) {
      me.handleDataChange(me.processValue(nextProps.value), true, true);
    }
    if (!isEqual(nextProps.jsxdata, me.props.jsxdata)) {
      me.setState({
        data: me.processData(nextProps.jsxdata)
      });
    }
  };

  SelectFormField.prototype.componentWillMount = function componentWillMount() {
    var me = this;
    if (me.props.jsxfetchUrl) {
      me.fetchData();
    }
  };

  SelectFormField.prototype.componentDidMount = function componentDidMount() {
    var me = this;
    if (!me.props.standalone) {
      me.props.attachFormField(me);
      me.props.handleDataChange(me, {
        value: me.processValue(me.props.value),
        pass: true
      }, true);
    }
    me.hasDeprecatedProps();
  };

  SelectFormField.prototype.handleDataChange = function handleDataChange(value, fromReset, silence) {
    var me = this;
    me.setState({
      value: value,
      formatValue: me.formatValue(value),
      error: fromReset ? false : me.state.error,
      /*
       * why set state fromReset? some field like editor cannot be reset in the common way
       * so set this state to tell the field that you need to reset by yourself.
       */
      fromReset: fromReset
    }, function () {
      var pass = true;
      if (!fromReset) {
        pass = me.doValidate();
      }
      if (me.props.handleDataChange) {
        me.props.handleDataChange(me, {
          value: value,
          pass: pass
        }, silence);
      }
    });
  };

  SelectFormField.prototype.fetchData = function fetchData(value) {
    var me = this;
    if (me.fetch) {
      me.fetch.abort();
    }
    me.fetch = NattyFetch.create({
      url: me.props.jsxfetchUrl,
      jsonp: me.props.dataType ? me.props.dataType === 'jsonp' : /\.jsonp/.test(me.props.jsxfetchUrl),
      data: me.props.beforeFetch({
        q: value
      }),
      fit: me.props.fitResponse,
      Promise: Promise
    });
    me.fetch().then(function (content) {
      var fetchData = me.processData(me.props.afterFetch(content));
      if (me.props.jsxdata) {
        fetchData = me.processData(me.props.jsxdata).concat(fetchData);
      }
      me.setState({
        data: fetchData
      });
    })["catch"](function (e) {
      console.error(e.stack);
    });
  };

  SelectFormField.prototype.handleChange = function handleChange(value, label) {
    var me = this;
    me.handleDataChange(value, false, label);
  };

  SelectFormField.prototype.handleSearch = function handleSearch(value) {
    var me = this;
    if (me.searchTimer) {
      clearTimeout(me.searchTimer);
    }
    me.searchTimer = setTimeout(function () {
      if (me.props.jsxfetchUrl) {
        me.fetchData(value);
      } else if (me.props.onSearch) {
        me.props.onSearch(value);
      }
    }, me.props.searchDelay);
  };

  /**
   * jsxdata can be one of two types: hash map or array
   * hash map is like {value: text}
   * array is like [{value: xxx, text: xxx}]
   */

  SelectFormField.prototype.processData = function processData(data) {
    var values = [];
    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && !(data instanceof Array)) {
      var keys = Object.keys(data);
      values = keys.map(function (key) {
        return {
          value: key,
          text: data[key]
        };
      });
    } else {
      values = data;
    }
    return values;
  };

  SelectFormField.prototype.transferDataToObj = function transferDataToObj(data) {
    var obj = {};
    data.forEach(function (item) {
      var key = item.value === '' ? '__all__' : item.value;
      obj[key] = item.text;
    });
    return obj;
  };

  SelectFormField.prototype._generateOptionsFromData = function _generateOptionsFromData() {
    var me = this;
    var values = me.state.data;
    var children = me.props.children;
    if (!values.length) {
      // console.warn("You need to pass data to initialize Select.");
      if (children) {
        return children;
      }
    }
    var arr = values.map(function (item) {
      return React.createElement(
        Option,
        { key: item.value, title: item.text },
        item.text
      );
    });
    return arr;
  };

  SelectFormField.prototype.processValue = function processValue(value) {
    var me = this;
    var newValue = value || me.state.value;
    if (!me.props.jsxfetchUrl && !me.props.onSearch) {
      return newValue;
    }
    if (typeof newValue === 'string') {
      return {
        key: newValue
      };
    } else if (newValue instanceof Array) {
      return newValue.map(function (item) {
        if (typeof item === 'string') {
          return {
            key: item
          };
        }
        return item;
      });
    }
    return newValue;
  };

  SelectFormField.prototype.addSpecificClass = function addSpecificClass() {
    var me = this;
    if (me.props.jsxprefixCls === 'kuma-uxform-field') {
      return me.props.jsxprefixCls + ' kuma-select-uxform-field';
    }
    return me.props.jsxprefixCls;
  };

  SelectFormField.prototype.getValuePropValue = function getValuePropValue(child) {
    var key = '';
    if ('value' in child.props) {
      key = child.props.value;
    } else {
      key = child.key;
    }
    return key;
  };

  SelectFormField.prototype.hasDeprecatedProps = function hasDeprecatedProps() {
    var arr = ['jsxmultiple', 'jsxallowClear', 'jsxcombobox', 'jsxsearchPlaceholder', 'jsxtags', 'jsxdisabled', 'jsxshowSearch', 'jsxplaceholder'];
    var me = this;
    var keys = Object.keys(me.props);
    var hasDeprecated = keys.some(function (item) {
      return arr.indexOf(item) !== -1;
    });
    if (hasDeprecated) {
      console.warn('SelectFormField: props same as \n        uxcore-select2 can be passed without prefix \'jsx\' now (exclude style). \n        we will remove the support of the props mentioned \n        above with prefix \'jsx\' at uxcore-form@1.3.0 .');
    }
  };

  SelectFormField.prototype.renderField = function renderField() {
    var me = this;
    var arr = [];
    var mode = me.props.jsxmode || me.props.mode;

    if (mode === Constants.MODE.EDIT) {
      (function () {
        var options = {
          ref: 'el',
          key: 'select',
          optionLabelProp: me.props.optionLabelProp,
          style: me.props.jsxstyle,
          multiple: me.props.jsxmultiple,
          allowClear: me.props.jsxallowClear,
          combobox: me.props.jsxcombobox,
          searchPlaceholder: me.props.jsxsearchPlaceholder,
          tags: me.props.jsxtags,
          optionFilterProp: me.props.optionFilterProp,
          disabled: !!me.props.jsxdisabled,
          showSearch: me.props.jsxshowSearch,
          placeholder: me.props.jsxplaceholder,
          onChange: me.handleChange.bind(me),
          onSearch: me.handleSearch.bind(me)
        };

        selectOptions.forEach(function (item) {
          if (item in me.props) {
            options[item] = me.props[item];
          }
        });

        // only jsxfetchUrl mode need pass label, for the options always change.
        // when mount, state.label is undefined, which cause defalutValue cannot be used.
        if (me.props.jsxfetchUrl || me.props.onSearch) {
          options.labelInValue = true;
        }

        if (!me.props.combobox || me.state.fromReset) {
          options.value = me.processValue() || [];
        }

        if (me.props.jsxfetchUrl) {
          options.filterOption = false;
        }
        arr.push(React.createElement(
          Select,
          options,
          me._generateOptionsFromData()
        ));
      })();
    } else if (mode === Constants.MODE.VIEW) {
      var str = '';
      if (me.state.value) {
        (function () {
          var value = me.processValue();
          var values = !isArray(value) ? [value] : value;
          // labelInValue mode
          if (me.props.jsxfetchUrl || me.props.onSearch || me.props.labelInValue) {
            str = values.map(function (item) {
              return item.label;
            }).join(' ');
          } else if (me.props.children) {
            // <Option> mode
            if (me.props.children) {
              me.props.children.forEach(function (child) {
                var valuePropValue = me.getValuePropValue(child);
                if (values.indexOf(valuePropValue) !== -1) {
                  str += child.props[me.props.optionLabelProp] + ' ';
                }
              });
            }
          } else {
            // only jsxdata
            values.forEach(function (item) {
              str += me.transferDataToObj(me.state.data)[item === '' ? '__all__' : item] + ' ';
            });
          }
        })();
      }
      arr.push(React.createElement(
        'span',
        { key: 'select' },
        str
      ));
    }
    return arr;
  };

  return SelectFormField;
}(FormField);

SelectFormField.Option = Option;
SelectFormField.displayName = 'SelectFormField';
SelectFormField.propTypes = assign({}, FormField.propTypes, {
  jsxstyle: React.PropTypes.object,
  jsxplaceholder: React.PropTypes.string,
  jsxcombobox: React.PropTypes.bool,
  jsxdata: React.PropTypes.oneOfType([React.PropTypes.object, React.PropTypes.array]),
  searchDelay: React.PropTypes.number,
  beforeFetch: React.PropTypes.func,
  afterFetch: React.PropTypes.func,
  jsxshowSearch: React.PropTypes.bool,
  jsxtags: React.PropTypes.bool,
  jsxmultiple: React.PropTypes.bool,
  jsxallowClear: React.PropTypes.bool,
  jsxsearchPlaceholder: React.PropTypes.string,
  optionFilterProp: React.PropTypes.string,
  dataType: React.PropTypes.string
});

SelectFormField.defaultProps = assign({}, FormField.defaultProps, {
  jsxstyle: {},
  jsxplaceholder: '请下拉选择',
  jsxcombobox: false,
  jsxdata: {},
  searchDelay: 100,
  beforeFetch: function beforeFetch(obj) {
    return obj;
  },
  afterFetch: function afterFetch(obj) {
    return obj;
  },
  fitResponse: function fitResponse(response) {
    return {
      content: response.content || response,
      success: response.success === undefined ? true : response.success
    };
  },
  jsxshowSearch: true,
  jsxallowClear: false,
  jsxtags: false,
  jsxmultiple: false,
  jsxsearchPlaceholder: '',
  optionFilterProp: 'children',
  optionLabelProp: 'children'
});

module.exports = SelectFormField;