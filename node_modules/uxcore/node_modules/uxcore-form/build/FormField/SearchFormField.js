'use strict';

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

/**
 * Created by xy on 15/4/13.
 */
var React = require('react');
var SelectFormField = require('uxcore-select-form-field');
var Constants = require("uxcore-const");
var Select = require('uxcore-select2');
var assign = require('object-assign');
var deepcopy = require('deepcopy');
var classnames = require('classnames');
var Option = Select.Option;

var selectOptions = ['onSelect', 'onDeselect', 'getPopupContainer', 'filterOption', 'allowClear', 'searchPlaceholder', 'tags', 'disabled', 'showSearch', 'placeholder', 'optionLabelProp', 'maxTagTextLength', 'dropdownMatchSelectWidth', 'dropdownClassName', 'notFoundContent'];

var SearchFormField = function (_SelectFormField) {
    _inherits(SearchFormField, _SelectFormField);

    function SearchFormField(props) {
        _classCallCheck(this, SearchFormField);

        return _possibleConstructorReturn(this, _SelectFormField.call(this, props));
    }

    SearchFormField.prototype.addSpecificClass = function addSpecificClass() {
        var me = this;
        if (me.props.jsxprefixCls == "kuma-uxform-field") {
            return me.props.jsxprefixCls + " kuma-search-uxform-field";
        } else {
            return me.props.jsxprefixCls;
        }
    };

    SearchFormField.prototype._processAdvanced = function _processAdvanced() {
        var me = this;
        var advancedOptions = me.props.advancedOptions;

        return advancedOptions.map(function (item) {
            return React.createElement(
                Option,
                { key: item.value, title: item.text },
                item.text
            );
        });
    };

    SearchFormField.prototype._processClassOptions = function _processClassOptions() {
        var me = this;
        var classOptions = me.props.classOptions;

        return classOptions.map(function (item) {
            return React.createElement(
                Option,
                { key: item.value, title: item.text },
                item.text
            );
        });
    };

    SearchFormField.prototype.handleChange = function handleChange(value, label) {
        var me = this;
        var stateValue = deepcopy(me.state.value) || {};
        stateValue.main = value;
        me.handleDataChange(stateValue, false, label);
    };

    SearchFormField.prototype.handleClassChange = function handleClassChange(value) {
        var me = this;
        var stateValue = deepcopy(me.state.value) || {};
        var label = me.state.label;
        stateValue["class"] = value;
        me.handleDataChange(stateValue, false, label);
    };

    SearchFormField.prototype.handleAdvancedChange = function handleAdvancedChange(value) {
        var me = this;
        var stateValue = deepcopy(me.state.value) || {};
        var label = me.state.label;
        stateValue.advanced = value;
        me.handleDataChange(stateValue, false, label);
    };

    SearchFormField.prototype.handleIconClick = function handleIconClick(e) {
        var me = this;
        me.props.onIconClick(e);
    };

    SearchFormField.prototype.renderField = function renderField() {
        var me = this;
        var arr = [];
        var mode = me.props.jsxmode || me.props.mode;
        var hasClass = me.props.classOptions instanceof Array && me.props.classOptions.length > 0;
        var hasAdvance = me.props.advancedOptions instanceof Array && me.props.advancedOptions.length > 0;

        var options = _defineProperty({
            ref: "el",
            key: "select",
            className: classnames({
                'has-class': hasClass,
                'has-advance': hasAdvance,
                'kuma-uxform-main-search': true
            }),
            optionFilterProp: me.props.optionFilterProp,
            combobox: me.props.combobox,
            onChange: me.handleChange.bind(me),
            onSearch: me.handleSearch.bind(me)
        }, 'key', 'search');

        selectOptions.forEach(function (item, index) {
            if (item in me.props) {
                options[item] = me.props[item];
            }
        });

        if (Object.keys(me.props.jsxdata).length > 0) {
            options.optionFilterProp = 'title';
        }

        // only jsxfetchUrl mode need pass label, for the options always change.
        // when mounted, state.label is undefined, which cause defalutValue cannot be used.
        if (!!me.props.jsxfetchUrl && !!me.state.label && me.state.label.length !== 0) {
            options.label = me.state.label || [];
        }

        if (!me.props.combobox || me.state.fromReset) {
            options.value = me.state.value.main || [];
        }

        if (!!me.props.jsxfetchUrl) {
            options.filterOption = false;
        }
        if (!me.props.tidy && hasClass) {
            arr.push(me.renderClassOptions());
        }
        arr.push(React.createElement(
            Select,
            options,
            me._generateOptionsFromData()
        ));

        if (!me.props.tidy && hasAdvance) {
            arr.push(me.renderAdvancedOptions());
        }
        arr.push(React.createElement(
            'span',
            { className: classnames({
                    "kuma-search-uxform-field-icon": true,
                    "tidy-pattern": me.props.tidy
                }), key: 'icon', onClick: me.handleIconClick.bind(me) },
            React.createElement('i', { className: 'kuma-icon kuma-icon-search' })
        ));
        return arr;
    };

    SearchFormField.prototype.renderClassOptions = function renderClassOptions() {
        var me = this;
        var _me$props$classConfig = me.props.classConfig;
        var className = _me$props$classConfig.className;
        var dropdownClassName = _me$props$classConfig.dropdownClassName;
        var onChange = _me$props$classConfig.onChange;

        var otherOptions = _objectWithoutProperties(_me$props$classConfig, ['className', 'dropdownClassName', 'onChange']);

        var options = assign({}, {
            showSearch: false,
            key: 'class',
            dropdownAlign: {
                offset: [0, 0]
            },
            dropdownClassName: classnames(_defineProperty({
                "kuma-uxform-class-dropdown": true
            }, dropdownClassName, !!dropdownClassName)),
            className: classnames(_defineProperty({
                "kuma-uxform-class-search": true
            }, className, !!className)),
            onChange: me.handleClassChange.bind(me)
        }, otherOptions);
        return React.createElement(
            Select,
            options,
            me._processClassOptions()
        );
    };

    SearchFormField.prototype.renderAdvancedOptions = function renderAdvancedOptions() {
        var me = this;
        var _me$props$advancedCon = me.props.advancedConfig;
        var className = _me$props$advancedCon.className;
        var dropdownClassName = _me$props$advancedCon.dropdownClassName;
        var onChange = _me$props$advancedCon.onChange;

        var otherOptions = _objectWithoutProperties(_me$props$advancedCon, ['className', 'dropdownClassName', 'onChange']);

        var options = assign({}, {
            showSearch: false,
            key: 'advanced',
            className: classnames(_defineProperty({
                'kuma-uxform-advanced-search': true
            }, className, !!className)),
            dropdownClassName: classnames(_defineProperty({
                "kuma-uxform-advanced-dropdown": true
            }, dropdownClassName, !!dropdownClassName)),
            dropdownAlign: {
                offset: [0, 0]
            },
            onChange: me.handleAdvancedChange.bind(me)
        }, otherOptions);
        return React.createElement(
            Select,
            options,
            me._processAdvanced()
        );
    };

    return SearchFormField;
}(SelectFormField);

SearchFormField.Option = Option;
SearchFormField.displayName = "SearchFormField";
SearchFormField.propTypes = assign({}, SelectFormField.propTypes, {
    advancedOptions: React.PropTypes.array,
    advancedConfig: React.PropTypes.object,
    classOptions: React.PropTypes.array,
    classConfig: React.PropTypes.object,
    tidy: React.PropTypes.bool,
    onIconClick: React.PropTypes.func
});
SearchFormField.defaultProps = assign({}, SelectFormField.defaultProps, {
    jsxshowLabel: false,
    combobox: true,
    showSearch: false,
    advancedConfig: {},
    classConfig: {},
    tidy: false,
    onIconClick: function onIconClick() {}
});

module.exports = SearchFormField;