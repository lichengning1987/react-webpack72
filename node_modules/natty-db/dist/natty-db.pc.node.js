(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

'use strict';

module.exports = __webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Defer = __webpack_require__(2);
var ajax = __webpack_require__(3);
var jsonp = __webpack_require__(5);
var util = __webpack_require__(4);
var event = __webpack_require__(6);

var extend = util.extend;
var runAsFn = util.runAsFn;
var isAbsoluteUrl = util.isAbsoluteUrl;
var isRelativeUrl = util.isRelativeUrl;
var noop = util.noop;
var isBoolean = util.isBoolean;
var isNumber = util.isNumber;
var isArray = util.isArray;
var isFunction = util.isFunction;
var each = util.each;

var NULL = null;
var EMPTY = '';
var TRUE = true;
var FALSE = !TRUE;

/**
 * 伪造的`promise`对象
 * NOTE 伪造的promise对象要支持链式调用 保证和`new Promise()`返回的对象行为一致
 *      dummyPromise.then().catch().finally()
 */
var dummyPromise = {
    dummy: TRUE
};
dummyPromise.then = dummyPromise['catch'] = dummyPromise['finally'] = function () {
    // NOTE 这里用了剪头函数 不能用`return this`
    return dummyPromise;
};

// 全局默认配置
var defaultGlobalConfig = {

    // 是否缓存
    cache: false,

    // 默认参数
    data: {},

    // 请求完成钩子函数
    didRequest: noop,

    // 预处理回调
    fit: noop,

    // 自定义header, 只针对非跨域的ajax有效, 跨域时将忽略自定义header
    header: {},

    // 是否忽律接口自身的并发请求
    ignoreSelfConcurrent: FALSE,

    // 有两种格式配置`jsonp`的值
    // {Boolean}
    // {Array} eg: [true, 'cb', 'j{id}']
    jsonp: FALSE,

    // 是否开启log信息
    log: FALSE,

    // 非GET方式对JSONP无效
    method: 'GET',

    // 是否开启mock模式
    mock: FALSE,

    mockUrl: EMPTY,

    // 全局`mockUrl`前缀
    mockUrlPrefix: EMPTY,

    // 成功回调
    process: noop,

    // 默认不执行重试
    retry: 0,

    // 使用已有的request方法
    request: NULL,

    // 0表示不启动超时处理
    timeout: 0,

    // http://zeptojs.com/#$.param
    traditional: FALSE,

    url: EMPTY,

    // 全局`url`前缀
    urlPrefix: EMPTY,

    withCredentials: NULL,

    // 请求之前调用的钩子函数
    willRequest: noop
};

var runtimeGlobalConfig = extend({}, defaultGlobalConfig);

var blackListForApiOptions = [];

var DB = (function () {
    // TODO 检查参数合法性

    function DB(name, APIs, context) {
        _classCallCheck(this, DB);

        var t = this;
        t.context = context;

        t.cache = {};
        t.name = name;
        for (var API in APIs) {
            t[API] = t.createAPI(extend({
                DBName: name,
                API: API
            }, runAsFn(APIs[API])));
        }
    }

    // 设计说明：
    //  1 jsonp不是"数据类型" 但很多人沟通时不经意使用"数据类型"这个词 因为jQuery/zepto的配置就是使用`dataType: 'jsonp'`

    /**
     * 关键词
     *     语意化的
     *     优雅的
     *     功能增强的
     *     底层隔离的
     *
     * 创建一个上下文
     *     let DBC = new NattyDB.Context({
     *          urlPrefix: 'xxx',
     *          mock: false,
     *          data: {
     *              token: 'xxx
     *          },
     *          timeout: 30000
     *     });
     * 创建一个DB
     *     let User = DBC.create('User', {
     *         getPhone: {
     *             url: 'xxx',
     *             mock: false,
     *             mockUrl: 'path',
     *
     *             method: 'GET',                // GET|POST
     *             data: {},                     // 固定参数
     *             header: {},                   // 非jsonp时才生效
     *             timeout: 5000,                // 如果超时了，会触发error
     *
     *             jsonp: false,                 // true
     *             jsonp: [true, 'cb', 'j{id}'], // 自定义jsonp的query string
     *
     *             fit: fn,
     *             process: fn,
     *
     *             retry: 0,
     *             ignoreSelfConcurrent: true,
     *
     *             log: true
     *         }
     *     });
     *
     * 使用
     *     User.getPhone({
     *         // 动态参数
     *     }).then(function () {
     *         // 成功回调
     *     }, function (error) {
     *         // 失败回调
     *         if (error.status == 404) {} // ajax方法才有error.status
     *         if (error.status == 500) {} // ajax方法才有error.status
     *         if (error.status == 0)      // ajax方法才有error.status 0表示不确定的错误 可能是跨域时使用了非法Header
     *         if (error.timeout) {
     *             console.log(error.message)
     *         }
     *
     *         // 服务器端返回的错误
     *         if (error.code == 10001) {}
     *     });
     *
     *     // 动态参数也可以是函数
     *     User.getPhone(function() {
     *         return {}
     *     }).then(function(){
     *         // 成功回调
     *     });
     *
     *     // 发起轮询
     *     // NOTE 轮询过程中是不响应服务器端错误的
     *     Driver.getDistance.startLoop({
     *         // 轮询发送的请求数据
     *         data: {},
     *         // 轮询发送的请求数据也支持函数
     *         data: function() {
     *             return {};
     *         },
     *
     *         // 间隔时间
     *         duration: 5000,
     *
     *         // 轮询的响应回调
     *         process: function(data) {}
     *     });
     *
     *     // 停止轮询
     *     // NOTE 关闭轮询的唯一方法就是stopLoop方法
     *     Driver.getDistance.stopLoop();
     *
     */

    /**
     * 处理API的配置
     * @param options {Object}
     */

    _createClass(DB, [{
        key: 'processAPIOptions',
        value: function processAPIOptions(options) {

            var t = this;
            var config = extend({}, t.context, options);

            // 过滤掉接口的黑名单配置
            //each(blackListForApiOptions, (option) => {
            //    delete  config[option];
            //});

            // 标记是否正在等待请求返回
            //C.log('init pending value')
            config.pending = FALSE;

            if (config.mock) {
                // dip平台强制使用`GET`方式, 因为不支持`GET`以外的类型
                // TODO 是否拿出去? 和dip平台耦合了
                config.method = 'GET';
                config.mockUrl = t.getFullUrl(config.mockUrl, true);
            }

            config.url = t.getFullUrl(options.url);

            // 按照[boolean, callbackKeyWord, callbackFunctionName]格式处理
            if (isArray(options.jsonp)) {
                config.jsonp = isBoolean(options.jsonp[0]) ? options.jsonp[0] : FALSE;
                // 这个参数只用于jsonp
                if (config.jsonp) {
                    config.jsonpFlag = options.jsonp[1];
                    config.jsonpCallbackName = options.jsonp[2];
                }
            }

            // 配置自动增强 如果`url`的值有`.jsonp`结尾 则认为是`jsonp`请求
            // NOTE jsonp是描述正式接口的 不影响mock接口!!!
            if (!config.mock && !!config.url.match(/\.jsonp(\?.*)?$/)) {
                config.jsonp = true;
            }

            return config;
        }

        /**
         * 创建一个`api`方法
         * @param options {Object} 一个`DB`的`api`的配置参数
         * @returns {Function} `api`方法
         * @note 一个`DB`对应若干个`api`函数
         * @note 一个api的构成如下:
         *    api.config {Object}
         *    api.looping {Boolean}
         *    api.startLoop {Function}
         *    api.stopLoop {Function}
         */
    }, {
        key: 'createAPI',
        value: function createAPI(options) {
            var t = this;
            var config = t.processAPIOptions(options);

            /**
             * 一个`DB`的`api`的实现
             * @param data {Object|Function}
             * @returns {Object} Promise Object
             */
            var api = function api(data) {
                // 是否忽略自身的并发请求
                if (config.ignoreSelfConcurrent && config.pending) {
                    return dummyPromise;
                }

                if (config.retry === 0) {
                    //C.log('request');
                    return t.request(data, config);
                } else {
                    return t.tryRequest(data, config);
                }
            };

            api.config = config;
            t.addLoopSupport(api);

            return api;
        }

        /**
         * 创建轮询支持
         * @param api {Function} 需要轮询的函数
         */
    }, {
        key: 'addLoopSupport',
        value: function addLoopSupport(api) {
            var loopTimer = null;
            api.looping = FALSE;
            // 开启轮询
            api.startLoop = function (options) {
                var resolveFn = arguments.length <= 1 || arguments[1] === undefined ? noop : arguments[1];
                var rejectFn = arguments.length <= 2 || arguments[2] === undefined ? noop : arguments[2];

                if (!options.duration || !isNumber(options.duration)) {
                    throw new Error('Illegal `duration` value for `startLoop` method.');
                    return api;
                }

                var sleepAndRequest = function sleepAndRequest() {
                    api.looping = TRUE;
                    loopTimer = setTimeout(function () {
                        api(options.data).then(resolveFn, rejectFn);
                        sleepAndRequest();
                    }, options.duration);
                };

                // NOTE 轮询过程中是不响应服务器端错误的 所以第二个参数是`noop`
                api(options.data).then(resolveFn, rejectFn);
                sleepAndRequest();
            };
            // 停止轮询
            api.stopLoop = function () {
                clearTimeout(loopTimer);
                api.looping = FALSE;
                loopTimer = null;
            };
        }

        /**
         * 获取正式接口的完整`url`
         * @param url {String}
         * @param isMock {Boolean} 是否是`mock`模式
         */
    }, {
        key: 'getFullUrl',
        value: function getFullUrl(url, isMock) {
            if (!url) return EMPTY;
            var prefixKey = isMock ? 'mockUrlPrefix' : 'urlPrefix';
            return this.context[prefixKey] && !isAbsoluteUrl(url) && !isRelativeUrl(url) ? this.context[prefixKey] + url : url;
        }

        /**
         * 发起请求
         * @param data {Object} 发送的数据
         * @param config {Object} 已经处理完善的请求配置
         * @param retryTime {undefined|Number} 如果没有重试 将是undefined值 见`createAPI`方法
         *                                     如果有重试 将是重试的当前次数 见`tryRequest`方法
         * @returns {Object} defer对象
         */
    }, {
        key: 'request',
        value: function request(data, config, retryTime) {
            var t = this;

            if (config.overrideSelfConcurrent && config._lastRequester) {
                config._lastRequester.abort();
                delete config._lastRequester;
            }

            // 一次请求的私有相关数据
            var vars = {
                mark: {
                    __api: t.name + '.' + config.API
                }
            };

            // 更新的重试次数
            vars.mark.__retryTime = retryTime;

            if (config.mock) {
                vars.m = 1;
            };

            // `data`必须在请求发生时实时创建
            data = extend({}, config.data, runAsFn(data));

            // 将数据参数存在私有标记中, 方便API的`process`方法内部使用
            vars.data = data;

            // 等待状态在此处开启 在相应的`requester`的`complete`回调中关闭
            config.pending = TRUE;

            // 调用 willRequest 钩子
            config.willRequest(vars, config);

            var defer = new Defer();

            // 创建请求实例requester
            if (config.request) {
                // 使用已有的request方法
                vars.requester = config.request(vars, config, defer);
            } else if (config.jsonp) {
                vars.requester = t.sendJSONP(vars, config, defer);
            } else {
                vars.requester = t.sendAjax(vars, config, defer);
            }

            // 如果只响应最新请求
            if (config.overrideSelfConcurrent) {
                config._lastRequester = vars.requester;
            }

            // 超时处理
            if (0 !== config.timeout) {
                setTimeout(function () {
                    if (config.pending) {
                        // 取消请求
                        vars.requester.abort();
                        delete vars.requester;
                        var error = {
                            timeout: TRUE,
                            message: 'Timeout By ' + config.timeout + 'ms.'
                        };
                        defer.reject(error);
                        event.fire('g.reject', [error, config]);
                        event.fire(config._contextId + '.reject', [error, config]);

                        // 调用 didRequest 钩子
                        config.didRequest(vars, config);
                    }
                }, config.timeout);
            }

            return defer.promise;
        }

        /**
         * 重试功能的实现
         * @param data {Object} 发送的数据
         * @param config
         * @returns {Object} defer对象
         */
    }, {
        key: 'tryRequest',
        value: function tryRequest(data, config) {
            var t = this;

            var defer = new Defer();
            var retryTime = 0;
            var request = function request() {
                t.request(data, config, retryTime).then(function (content) {
                    defer.resolve(content);
                    event.fire('g.resolve', [content, config], config);
                    event.fire(config._contextId + '.resolve', [content, config], config);
                }, function (error) {
                    if (retryTime === config.retry) {
                        defer.reject(error);
                    } else {
                        retryTime++;
                        request();
                    }
                });
            };

            request();
            return defer.promise;
        }

        /**
         * 处理结构化的响应数据
         * @param config
         * @param response
         * @param defer
         */
    }, {
        key: 'processResponse',
        value: function processResponse(vars, config, defer, response) {
            var t = this;

            // 调用 didRequest 钩子函数
            config.didRequest(vars, config);

            // 非标准格式数据的预处理
            response = config.fit(response, vars);

            if (response.success) {
                // 数据处理
                var content = config.process(response.content, vars);

                defer.resolve(content);
                event.fire('g.resolve', [content, config], config);
                event.fire(config._contextId + '.resolve', [content, config], config);
            } else {
                var error = extend({
                    message: 'Processing Failed: ' + config.DBName + '.' + config.API
                }, response.error);
                // NOTE response是只读的对象!!!
                defer.reject(error);
                event.fire('g.reject', [error, config]);
                event.fire(config._contextId + '.reject', [error, config]);
            }
        }

        /**
         * 发起Ajax请求
         * @param config {Object} 请求配置
         * @param defer {Object} defer对象
         * @param retryTime {undefined|Number} 如果没有重试 将是undefined值 见`createAPI`方法
         *                                     如果有重试 将是重试的当前次数 见`tryRequest`方法
         * @returns {Object} xhr对象实例
         */
    }, {
        key: 'sendAjax',
        value: function sendAjax(vars, config, defer) {
            var t = this;

            return ajax({
                traditional: config.traditional,
                cache: config.cache,
                mark: vars.mark,
                log: config.log,
                url: config.mock ? config.mockUrl : config.url,
                method: config.method,
                data: vars.data,
                header: config.header,
                withCredentials: config.withCredentials,
                // 强制约定json
                accept: 'json',
                success: function success(response /*, xhr*/) {
                    t.processResponse(vars, config, defer, response);
                },
                error: function error(status /*, xhr*/) {

                    var message = undefined;
                    var flag = undefined;
                    switch (status) {
                        case 404:
                            message = 'Not Found';
                            break;
                        case 500:
                            message = 'Internal Server Error';
                            break;
                        // TODO 是否要补充其他明确的服务端错误
                        default:
                            message = 'Unknown Server Error';
                            break;
                    }

                    defer.reject({
                        status: status,
                        message: message
                    });
                },
                complete: function complete() /*status, xhr*/{

                    if (vars.retryTime === undefined || vars.retryTime === config.retry) {
                        //C.log('ajax complete');

                        config.pending = FALSE;
                        vars.requester = NULL;

                        // 如果只响应最新请求
                        if (config.overrideSelfConcurrent) {
                            delete config._lastRequester;
                        }
                    }
                    //console.log('__complete: pending:', config.pending, 'retryTime:', retryTime, Math.random());
                }
            });
        }

        /**
         * 发起jsonp请求
         * @param vars {Object} 一次请求相关的私有数据
         * @param config {Object} 请求配置
         * @param defer {Object} defer对象
         * @param retryTime {undefined|Number} 如果没有重试 将是undefined值 见`createAPI`方法
         *                                     如果有重试 将是重试的当前次数 见`tryRequest`方法
         * @returns {Object} 带有abort方法的对象
         */
    }, {
        key: 'sendJSONP',
        value: function sendJSONP(vars, config, defer) {
            var t = this;
            return jsonp({
                traditional: config.traditional,
                log: config.log,
                mark: vars.mark,
                url: config.mock ? config.mockUrl : config.url,
                data: vars.data,
                cache: config.cache,
                flag: config.jsonpFlag,
                callbackName: config.jsonpCallbackName,
                success: function success(response) {
                    t.processResponse(vars, config, defer, response);
                },
                error: function error(e) {
                    defer.reject({
                        message: 'Not Accessable JSONP `'
                        //    TODO show url
                    });
                },
                complete: function complete() {
                    if (vars.retryTime === undefined || vars.retryTime === config.retry) {
                        config.pending = FALSE;
                        vars.requester = NULL;

                        // 如果只响应最新请求
                        if (config.overrideSelfConcurrent) {
                            delete config._lastRequester;
                        }
                    }
                    //console.log('complete: pending:', config.pending);
                }
            });
        }
    }]);

    return DB;
})();

var Context = (function () {
    /**
     * @param options 一个DB实例的通用配置
     */

    function Context(options) {
        _classCallCheck(this, Context);

        var t = this;
        options = options || {};
        var contextId = 'c' + Context.count++;
        t.contextId = contextId;

        t.config = extend({}, runtimeGlobalConfig, options, {
            _contextId: contextId
        });
    }

    // 用于给DB上下文命名
    // 如: 第一个和第二个上下文的`resolve`的事件 在event中的记录分别是:
    //     c1.resolve
    //     c2.resolve

    /**
     * 创建一个`DB`
     * @param DBName {String} `DB`的名称 不可重复
     * @param APIs {Object} 该`DB`下的`api`配置
     * @returns {Object} 返回创建好的`DB`实例
     */

    _createClass(Context, [{
        key: 'create',
        value: function create(DBName, APIs) {
            var t = this;
            // NOTE 强制不允许重复的DB名称
            if (t[DBName]) {
                throw new Error('DB: "' + DBName + '" is existed! ');
                return;
            }

            return t[DBName] = new DB(DBName, APIs, t.config);
        }

        // 绑定上下文事件
    }, {
        key: 'on',
        value: function on(name, fn) {
            if (!isFunction(fn)) return;
            event.on(this.contextId + '.' + name, fn);
            return this;
        }
    }]);

    return Context;
})();

Context.count = 0;

var VERSION = undefined;
(VERSION = "1.0.2");

var NattyDB = {
    onlyForHTML5: FALSE,
    version: VERSION,
    Context: Context,
    _util: util,
    _event: event,
    ajax: ajax,
    jsonp: jsonp,

    /**
     * 执行全局配置
     * @param options
     */
    setGlobal: function setGlobal(options) {
        runtimeGlobalConfig = extend({}, defaultGlobalConfig, options);
        return this;
    },

    /**
     * 获取全局配置
     * @param property {String} optional
     * @returns {*}
     */
    getGlobal: function getGlobal(property) {
        return property ? runtimeGlobalConfig[property] : runtimeGlobalConfig;
    },

    // 绑定全局事件
    on: function on(name, fn) {
        if (!isFunction(fn)) return;
        event.on('g.' + name, fn);
        return this;
    }
};

// 内部直接将运行时的全局配置初始化到默认值
NattyDB.setGlobal(defaultGlobalConfig);

module.exports = NattyDB;

/***/ },
/* 2 */
/***/ function(module, exports) {

"use strict";

function Defer() {
  var t = this;
  t.promise = new Promise(function (resolve, reject) {
    t._resolve = resolve;
    t._reject = reject;
  });
}
Defer.prototype.resolve = function (value) {
  this._resolve.call(this.promise, value);
};
Defer.prototype.reject = function (reason) {
  this._reject.call(this.promise, reason);
};
module.exports = Defer;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

/**
 * ref https://xhr.spec.whatwg.org
 * ref https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
 * ref https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
 * ref https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS
 * ref https://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/
 * ref http://www.html5rocks.com/en/tutorials/cors/
 * @link http://enable-cors.org/index.html
 */
'use strict';

var _require = __webpack_require__(4);

var extend = _require.extend;
var appendQueryString = _require.appendQueryString;
var noop = _require.noop;
var isCrossDomain = _require.isCrossDomain;
var isBoolean = _require.isBoolean;
var param = _require.param;

var hasWindow = 'undefined' !== typeof window;
var doc = hasWindow ? document : null;
var FALSE = false;
var UNDEFINED = 'undefined';
var NULL = null;
var GET = 'GET';
var SCRIPT = 'script';
var XML = 'xml';
var HTML = 'html';
var TEXT = 'text';
var JS0N = 'json'; // NOTE 不能使用`JSON`，这里用数字零`0`代替了字母`O`

var APPLICATION_JSON = 'application/json';
var TEXT_HTML = 'text/html';

var xhrTester = UNDEFINED !== typeof XMLHttpRequest ? new XMLHttpRequest() : {};
var hasXDR = UNDEFINED !== typeof XDomainRequest;
var fallback = hasWindow ? !('withCredentials' in xhrTester) && hasXDR : null;
var supportCORS = hasWindow ? 'withCredentials' in xhrTester || hasXDR : null;

// minetype的简写映射
// TODO 考虑是否优化
var acceptToRequestHeader = {
    // IIS returns `application/x-javascript` 但应该不需要支持
    '*': '*/' + '*',
    script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript',
    json: 'application/json, text/json',
    xml: 'application/xml, text/xml',
    html: 'text/html',
    text: 'text/plain'
};

// 设置请求头
// 没有处理的事情：跨域时使用者传入的多余的Header没有屏蔽 没必要
var setHeaders = function setHeaders(xhr, options) {
    if (!xhr.setRequestHeader) {
        return;
    }

    var header = {
        Accept: acceptToRequestHeader[options.accept]
    };

    // 如果没有跨域 则打该标识 业界通用做法
    // TODO 如果是跨域的 只有有限的requestHeader是可以使用的 待补充注释
    if (!isCrossDomain(options.url)) {
        header['X-Requested-With'] = 'XMLHttpRequest';
    }

    extend(header, options.header);

    // 如果是`POST`请求，需要`urlencode`
    if (options.method === 'POST' && !options.header['Content-Type']) {
        header['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
    }

    for (var key in header) {
        xhr.setRequestHeader(key, header[key]);
    }
};

// 绑定事件
var setEvents = function setEvents(xhr, options, isCrossDomain) {

    var completeFn = function completeFn() {
        if (xhr.__completed) {
            return;
        }
        xhr.__completed = true;
        //options.log && console.info('~loadend');
        options.complete(xhr.status, xhr);
        xhr.__aborted = null;
        delete xhr.__aborted;
    };

    var onLoadFn = function onLoadFn() {

        var data = xhr.responseText;

        switch (options.accept) {
            case JS0N:
                try {
                    data = JSON.parse(data);
                } catch (e) {
                    console.warn('The response can NOT be parsed to JSON object.', data);
                }
                break;
            case SCRIPT:
                (1, eval)(data);
                break;
            case XML:
                data = xhr.responseXML;
                break;
            //case HTML:
            //case TEXT:
            default:
                break;
        }
        options.success(data, xhr);
        //C.log('complete after load');
        completeFn();
    };

    var onErrorFn = function onErrorFn() {
        options.error(xhr.status, xhr);
        //C.log('complete after error');
        completeFn();
    };

    var abortFn = function abortFn() {
        if (xhr.__completed) {
            return;
        }
        //options.log && console.info('~abort');
        options.abort(xhr.status, xhr);
        //C.log('complete after abort');
        completeFn();
    };

    // 如果是IE8/9 且 如果是跨域请求
    if (fallback && isCrossDomain) {
        // `XDomainRequest`实例是没有`onreadystatechange`方法的!!!
        xhr.onload = onLoadFn;
    } else {
        // readyState value:
        //   0: UNSET 未初始化
        //   1: OPENED
        //   2: HEADERS_RECEIVED
        //   3: LOADING
        //   4: DONE 此时触发load事件
        xhr.onreadystatechange = function () {
            //console.log('xhr.readyState', xhr.readyState, 'xhr.status', xhr.status, xhr);
            if (xhr.readyState == 4) {
                // 如果请求被取消(aborted) 则`xhr.status`会是0 所以不会进入`success`回调
                if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
                    onLoadFn();
                } else {
                    // 如果请求被取消(aborted) 则`xhr.status`会是0 程序也会到达这里 需要排除 不应该触发error
                    !xhr.__aborted && onErrorFn();
                }
            }
        };
    }

    xhr.onerror = onErrorFn;

    // 重写`abort`方法
    var originAbort = xhr.abort;
    xhr.abort = function () {
        xhr.__aborted = true;
        // NOTE 直接调用`originAbort()`时 浏览器会报 `Illegal invocation` 错误
        originAbort.call(xhr);

        // `XDomainRequest`对象实例居然没有`onabort`方法
        abortFn();
    };

    // IE9 bug
    xhr.onprogress = xhr.ontimeout = noop;
};

var defaultOptions = {
    url: '',
    mark: {},
    method: GET,
    accept: TEXT,
    data: null,
    header: {},
    withCredentials: NULL, // 根据`url`是否跨域决定默认值. 如果显式配置该值(必须是布尔值), 则个使用配置值
    cache: true,
    success: noop,
    error: noop,
    complete: noop,
    abort: noop,
    log: FALSE,
    traditional: FALSE
};

var ajax = function ajax(options) {

    options = extend({}, defaultOptions, options);

    // 是否跨域
    var isCD = isCrossDomain(options.url);

    // 如果跨域了, 则禁止发送自定义的`header`信息
    if (isCD) {
        // 重置`header`, 统一浏览器的行为.
        // 如果在跨域时发送了自定义`header`, 则:
        //   标准浏览器会报错: Request header field xxx is not allowed by Access-Control-Allow-Headers in preflight response.
        //   IE浏览器不报错
        options.header = {};
    }

    // H5版本
    // `IE10+`和标准浏览器的`XMLHttpRequest`都原生支持跨域
    var xhr = new XMLHttpRequest();

    // `IE8/9`使用`XDomainRequest`来实现跨域, `IE10+`的`XMLHttpRequest`对象直接支持跨域
    if (fallback && isCD) {
        // NOTE `XDomainRequest`仅支持`GET`和`POST`两个方法
        // 支持的事件有: onerror, onload, onprogress, ontimeout, 注意没有`onloadend`
        // https://developer.mozilla.org/zh-CN/docs/Web/API/XDomainRequest
        xhr = new XDomainRequest();
    }

    // 再高级的浏览器都有低级错误! 已经不能在相信了!
    // MAC OSX Yosemite Safari上的低级错误: 一次`ajax`请求的`loadend`事件完成之后,
    // 如果执行`xhr.abort()`, 居然还能触发一遍`abort`和`loadend`事件!!!
    // `__completed`标识一次完整的请求是否结束, 如果已结束, 则不再触发任何事件
    xhr.__completed = FALSE;

    setEvents(xhr, options, isCD);

    xhr.open(options.method, appendQueryString(options.url, extend({}, options.mark, options.method === GET ? options.data : {}), options.cache, options.traditional));

    // NOTE 生产环境的Server端, `Access-Control-Allow-Origin`的值一定不要配置成`*`!!! 而且`Access-Control-Allow-Credentials`应该是true!!!
    // NOTE 如果Server端的`responseHeader`配置了`Access-Control-Allow-Origin`的值是通配符`*` 则前端`withCredentials`是不能使用true值的
    // NOTE 如果Client端`withCredentials`使用了true值 则后端`responseHeader`中必须配置`Access-Control-Allow-Credentials`是true
    if (!fallback) {
        xhr.withCredentials = isBoolean(options.withCredentials) ? options.withCredentials : isCD;
    }

    // 设置requestHeader
    setHeaders(xhr, options);

    // 文档建议说 send方法如果不发送请求体数据 则null参数在某些浏览器上是必须的

    xhr.send(options.method === GET ? NULL : options.data !== NULL ? param(options.data, options.traditional) : NULL);

    return xhr;
};

ajax.fallback = fallback;
ajax.supportCORS = supportCORS;

module.exports = ajax;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

'use strict';

var hasWindow = 'undefined' !== typeof window;
var doc = hasWindow ? document : null;
var escape = encodeURIComponent;
var NULL = null;
var toString = Object.prototype.toString;
var ARRAY_TYPE = '[object Array]';
var OBJECT_TYPE = '[object Object]';

/**
 * 判断是否是IE8~11, 不包含Edge
 * @returns {boolean}
 * @note IE11下 window.ActiveXObject的值很怪异, 所有需要追加 'ActiveXObject' in window 来判断
 */
var isIE = hasWindow && (!!window.ActiveXObject || 'ActiveXObject' in window);

var noop = function noop(v) {
    return v;
};

/**
 * 变换两个参数的函数到多个参数
 * @param  {Function} fn 基函数
 * @return {Function} 变换后的函数
 * @demo
 *      function add(x, y) { return x+y; }
 *      add = redo(add);
 *      add(1,2,3) => 6
 */
var redo = function redo(fn) {
    return function () {
        var args = arguments;
        var ret = fn(args[0], args[1]);
        for (var i = 2, l = args.length; i < l; i++) {
            ret = fn(ret, args[i]);
        }
        return ret;
    };
};

var random = Math.random;
var floor = Math.floor;
var makeRandom = function makeRandom() {
    return floor(random() * 9e9);
};

var absoluteUrlReg = /^(https?:)?\/\//;
var isAbsoluteUrl = function isAbsoluteUrl(url) {
    return !!url.match(absoluteUrlReg);
};

var relativeUrlReg = /^[\.\/]/;
var isRelativeUrl = function isRelativeUrl(url) {
    return !!url.match(relativeUrlReg);
};

var BOOLEAN = 'boolean';
var isBoolean = function isBoolean(v) {
    return typeof v === BOOLEAN;
};

var FUNCTION = 'function';
var isFunction = function isFunction(v) {
    return typeof v === FUNCTION;
};

var runAsFn = function runAsFn(v) {
    return isFunction(v) ? v() : v;
};

var NUMBER = 'number';
var isNumber = function isNumber(v) {
    return !isNaN(v) && typeof v === NUMBER;
};

var OBJECT = 'object';
var isObject = function isObject(v) {
    return typeof v === OBJECT;
};

var isWindow = function isWindow(v) {
    return v !== NULL && v === v.window;
};

// 参考了zepto
var isPlainObject = function isPlainObject(v) {
    return v !== NULL && isObject(v) && !isWindow(v) && Object.getPrototypeOf(v) === Object.prototype;
};

var isArray = Array.isArray;
if (true) {
    if (!isArray) {
        isArray = function (v) {
            return toString.call(v) === ARRAY_TYPE;
        };
    }
}

/**
 * 判断是否跨域
 * @type {Element}
 * @note 需要特别关注IE8~11的行为是不一样的!!!
 */
var originA = undefined;
if (doc) {
    originA = doc.createElement('a');
    originA.href = location.href;
}
var isCrossDomain = function isCrossDomain(url) {

    var requestA = doc.createElement('a');
    requestA.href = url;
    //console.log(originA.protocol + '//' + originA.host + '\n' + requestA.protocol + '//' + requestA.host);

    // 如果`url`的值不包含`protocol`和`host`(比如相对路径), 在标准浏览器下, 会自定补全`requestA`对象的`protocal`和`host`属性.
    // 但在IE8~11下, 不会自动补全. 即`requestA.protocol`和`requestA.host`的值都是空的.
    // 在IE11的不同小版本下, requestA.protocol的值有的是`:`, 有的是空字符串, 太奇葩啦!
    if (true) {
        if (isIE && (requestA.protocol === ':' || requestA.protocol === '')) {
            if (requestA.hostname === '') {
                //alert(0)
                return false;
            } else {
                //alert('1:'+(originA.hostname !== requestA.hostname || originA.port !== requestA.port))
                return originA.hostname !== requestA.hostname || originA.port !== requestA.port;
            }
        }
    }

    //let log = {
    //    'originA.hostname': originA.hostname,
    //    'requestA.hostname': requestA.hostname,
    //    'originA.port': originA.port,
    //    'requestA.port': requestA.port,
    //    'originA.protocol': originA.protocol,
    //    'requestA.protocol': requestA.protocol
    //}
    //
    //alert(JSON.stringify(log));

    // 标准浏览器
    return originA.hostname !== requestA.hostname || originA.port !== requestA.port || originA.protocol !== requestA.protocol;
};

/**
 * 对象扩展
 * @param  {Object} receiver
 * @param  {Object} supplier
 * @return {Object} 扩展后的receiver对象
 * @note 这个extend方法是定制的, 不要拷贝到其他地方用!!!
 */
var extend = function extend() {
    var receiver = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var supplier = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    for (var key in supplier) {
        // `supplier`中不是未定义的键 都可以执行扩展
        if (supplier.hasOwnProperty(key) && supplier[key] !== undefined) {
            if (isArray(supplier[key])) {
                receiver[key] = [].concat(supplier[key]);
            } else if (isPlainObject(supplier[key])) {
                receiver[key] = extend({}, supplier[key]);
            } else {
                receiver[key] = supplier[key];
            }
        }
    }
    return receiver;
};

var likeArray = function likeArray(v) {
    if (!v) {
        return false;
    }
    return typeof v.length === NUMBER;
};

/**
 *
 * @param v {Array|Object} 遍历目标对象
 * @param fn {Function} 遍历器 会被传入两个参数, 分别是`value`和`key`
 */
var each = function each(v, fn) {
    var i = undefined,
        l = undefined;
    if (likeArray(v)) {
        for (i = 0, l = v.length; i < l; i++) {
            if (fn.call(v[i], v[i], i) === false) return;
        }
    } else {
        for (i in v) {
            if (fn.call(v[i], v[i], i) === false) return;
        }
    }
};

//
var serialize = function serialize(params, obj, traditional, scope) {
    var type = undefined,
        array = isArray(obj),
        hash = isPlainObject(obj);
    each(obj, function (value, key) {
        type = toString.call(value);
        if (scope) {
            key = traditional ? scope : scope + '[' + (hash || type == OBJECT_TYPE || type == ARRAY_TYPE ? key : '') + ']';
        }

        // 递归
        if (!scope && array) {
            params.add(value.name, value.value);
        }
        // recurse into nested objects
        else if (type == ARRAY_TYPE || !traditional && type == OBJECT_TYPE) {
                serialize(params, value, traditional, key);
            } else {
                params.add(key, value);
            }
    });
};

/**
 * 功能和`Zepto.param`一样
 * @param obj {Object}
 * @param traditional {Boolean}
 * @returns {string}
 * $.param({ foo: { one: 1, two: 2 }}) // "foo[one]=1&foo[two]=2)"
 * $.param({ ids: [1,2,3] })           // "ids[]=1&ids[]=2&ids[]=3"
 * $.param({ ids: [1,2,3] }, true)     // "ids=1&ids=2&ids=3"
 * $.param({ foo: 'bar', nested: { will: 'not be ignored' }})    // "foo=bar&nested[will]=not+be+ignored"
 * $.param({ foo: 'bar', nested: { will: 'be ignored' }}, true)  // "foo=bar&nested=[object+Object]"
 * $.param({ id: function(){ return 1 + 2 } })  // "id=3"
 */
var param = function param(obj, traditional) {
    var params = [];
    params.add = function (key, value) {
        if (isFunction(value)) value = value();
        if (value == NULL) value = '';
        params.push(escape(key) + '=' + escape(value));
    };
    serialize(params, obj, traditional);
    return params.join('&').replace(/%20/g, '+');
};

var decodeParam = function decodeParam(str) {
    return decodeURIComponent(str.replace(/\+/g, ' '));
};

// 给URL追加查询字符串
var appendQueryString = function appendQueryString(url, obj, cache, traditional) {
    //let kv = [];

    // 是否追加noCache参数
    if (!cache) {
        obj.__noCache = makeRandom();
    }

    var queryString = param(obj, traditional);
    //!cache && kv.push('noCache=' + makeRandom());

    //for (let key in obj) {
    //    if (obj.hasOwnProperty(key)) {
    //        kv.push(escape(key) + '=' + escape(obj[key]));
    //    }
    //}

    if (queryString) {
        return url + (~url.indexOf('?') ? '&' : '?') + queryString;
    } else {
        return url;
    }
};

module.exports = {
    isIE: isIE,
    extend: redo(extend),
    each: each,
    makeRandom: makeRandom,
    appendQueryString: appendQueryString,
    noop: noop,
    isCrossDomain: isCrossDomain,
    isAbsoluteUrl: isAbsoluteUrl,
    isRelativeUrl: isRelativeUrl,
    isBoolean: isBoolean,
    isFunction: isFunction,
    isNumber: isNumber,
    isArray: isArray,
    param: param,
    decodeParam: decodeParam,
    runAsFn: runAsFn
};

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = __webpack_require__(4);

var appendQueryString = _require.appendQueryString;
var noop = _require.noop;
var extend = _require.extend;
var makeRandom = _require.makeRandom;

var hasWindow = 'undefined' !== typeof window;
var win = hasWindow ? window : null;
var doc = hasWindow ? document : null;
var NULL = null;
var SCRIPT = 'script';
var FALSE = false;
var IE8 = hasWindow ? navigator.userAgent.indexOf('MSIE 8.0') > -1 : false;
// TODO add test spec
var removeScript = function removeScript(script) {
    if (IE8 && script.readyState) {
        script.onreadystatechange = NULL;
    } else {
        script.onerror = NULL;
    }
    script.parentNode.removeChild(script);
    script = NULL;
};
var head = NULL;
var insertScript = function insertScript(url, options) {
    var script = doc.createElement(SCRIPT);
    script.type = 'text/javascript';
    script.src = url;
    script.async = true;

    // 绑定`error`事件
    if (IE8 && script.readyState) {
        script.onreadystatechange = function () {
            // IE8下script标签不支持`onerror`事件, 通过JSONP的执行顺序来模拟触发:
            // 1:   script.readyState状态值为`loading`
            // 2.1: 如果脚本加载成功, 浏览器就会先执行脚本内容, 即调用JSONP函数, 如: `jsonp2327905726()`,
            //      (该函数执行之后会立即被设置成`null`值, 用于第3步的判断), JSONP函数执行完成后, 会进入第3步.
            // 2.2: 如果脚本加载不成功, 也会进入第3步.
            // 3:   无论脚本是否加载成功, `script.readyState`状态值都变化为`loaded`,
            //      如果加载不成功, 可以通过判断JSONP函数一定是存在, 即可模拟`error`回调了.
            if (script.readyState === 'loaded' && win[options.callbackName]) {
                win[options.callbackName] = NULL;
                options.error();
                options.complete();
            }
        };
    } else {
        script.onerror = function (e) {
            win[options.callbackName] = NULL;
            options.error(e);
            options.complete();
        };
    }

    head = head || doc.getElementsByTagName('head')[0];
    head.insertBefore(script, head.firstChild);
    return script;
};

var defaultOptions = {
    url: '',
    mark: {},
    data: {},
    cache: true,
    success: noop,
    error: noop,
    complete: noop,
    log: false,
    flag: 'callback',
    callbackName: 'jsonp{id}',
    traditional: FALSE
};

var jsonp = function jsonp(options) {

    options = extend({}, defaultOptions, options);

    var callbackName = options.callbackName = options.callbackName.replace(/\{id\}/, makeRandom());

    var originComplete = options.complete;

    var script = undefined;

    // 二次包装的`complete`回调
    options.complete = function () {
        // 删除脚本
        removeScript(script);
        originComplete();
    };

    // 成功回调
    win[callbackName] = function (data) {
        // JSONP函数需要立即删除 用于`IE8`判断是否触发`onerror`
        win[callbackName] = NULL;
        options.success(data);
        options.complete();
    };

    // 生成`url`
    var url = appendQueryString(options.url, extend(_defineProperty({}, options.flag, callbackName), options.mark, options.data), options.cache, options.traditional);

    // 插入脚本
    script = insertScript(url, options);

    return {
        abort: function abort() {
            // 覆盖成功回调为无数据处理版本
            win[callbackName] = function () {
                win[callbackName] = NULL;
            };
            removeScript(script);
        }
    };
};

module.exports = jsonp;

/***/ },
/* 6 */
/***/ function(module, exports) {

'use strict';

var pre = '__';

var Event = {
    on: function on() {
        var t = this;
        var args = arguments;
        if (typeof args[0] === 'string' && typeof args[1] === 'function') {
            var type = rename(args[0]);
            t[type] = t[type] || [];
            t[type].push(args[1]);
        } else if (typeof args[0] === 'object') {
            var hash = args[0];
            for (var i in hash) {
                t.on(i, hash[i]);
            }
        }
    },
    off: function off(type, fn) {
        var t = this;
        var type = rename(type);
        if (!fn) {
            delete t[type];
        } else {
            var fns = t[type];
            fns.splice(fns.indexOf(fn), 1);
            if (!t[type].length) delete t[type];
        }
    },
    // @param {array} args
    fire: function fire(type, args, context) {
        var t = this;
        var fns = t[rename(type)];
        if (!fns) return 'NO_EVENT';
        for (var i = 0, fn; fn = fns[i]; i++) {
            fn.apply(context || t, [].concat(args));
        }
    },
    hasEvent: function hasEvent(type) {
        return !!this[rename(type)];
    }
};

function rename(type) {
    return pre + type;
}

module.exports = Event;

/***/ }
/******/ ])));